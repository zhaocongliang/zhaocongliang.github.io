<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>Go实现公链底层开发（四）</title>
  <meta name="description" content="交易（transaction）是比特币的核心所在，而区块链唯一的目的，也正是为了能够安全可靠地存储交易。在区块链中，交易一旦被创建，就没有任何人能够再去修改或是删除它。今天，我们将会开始实现交易。不过，由于交易是很大的话题，我会把它分为两部分来讲：在今天这个部分，我们会实现交易的基本框架。在第二部分，我们会继续讨论它的一些细节。由于比特币采用的是 UTXO 模型，并非账户模型，并不直接存在“余额”这个概念，余额需要通过遍历整个交易历史得来。">
  <meta name="author" content="赵从亮">

  <meta name="keywords" content="公链底层"
  />

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Go实现公链底层开发（四）">
  <meta name="twitter:description" content="交易（transaction）是比特币的核心所在，而区块链唯一的目的，也正是为了能够安全可靠地存储交易。在区块链中，交易一旦被创建，就没有任何人能够再去修改或是删除它。今天，我们将会开始实现交易。不过，由于交易是很大的话题，我会把它分为两部分来讲：在今天这个部分，我们会实现交易的基本框架。在第二部分，我们会继续讨论它的一些细节。由于比特币采用的是 UTXO 模型，并非账户模型，并不直接存在“余额”这个概念，余额需要通过遍历整个交易历史得来。">

  <meta property="og:type" content="article">
  <meta property="og:title" content="Go实现公链底层开发（四）">
  <meta property="og:description" content="交易（transaction）是比特币的核心所在，而区块链唯一的目的，也正是为了能够安全可靠地存储交易。在区块链中，交易一旦被创建，就没有任何人能够再去修改或是删除它。今天，我们将会开始实现交易。不过，由于交易是很大的话题，我会把它分为两部分来讲：在今天这个部分，我们会实现交易的基本框架。在第二部分，我们会继续讨论它的一些细节。由于比特币采用的是 UTXO 模型，并非账户模型，并不直接存在“余额”这个概念，余额需要通过遍历整个交易历史得来。">
  <meta property="og:site_name" content="公链底层e"
  />


  <link rel="icon" type="image/png" href="/images/favicon.png" />
  <link href="/images/favicon.png" rel="shortcut icon" type="image/png">


  <link rel="stylesheet" href=" /css/main.css ">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="http://localhost:4000/2017/08/20/blockchain-dev/">
  <link rel="alternate" type="application/rss+xml" title="赵从亮区块链博客" href="http://localhost:4000 /feed.xml
    ">

  <meta name="google-site-verification" content="1-1ZlHoRvM0T2FqPbW2S-qLgYXN6rsn52kErlMPd_gw" />

  <!-- 站点统计 -->
  <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
  </script>
  <!-- <script>(function() {var _53code = document.createElement("script");_53code.src = "https://tb.53kf.com/code/code/10174862/1";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(_53code, s);})();</script> -->
  <!-- 百度统计 -->
  
  <script>
    var _hmt = _hmt || [];
    (function () {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?f3290601666dc2ca016a38c340c144f1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>
  

  <!-- google 统计 -->
  
  <script>
    (function (i, s, o, g, r, a, m) {
      i['GoogleAnalyticsObject'] = r;
      i[r] = i[r] || function () {
        (i[r].q = i[r].q || []).push(arguments)
      }, i[r].l = 1 * new Date();
      a = s.createElement(o),
        m = s.getElementsByTagName(o)[0];
      a.async = 1;
      a.src = g;
      m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
    ga('create', 'UA-104237177-1', 'auto');
    ga('send', 'pageview');
  </script>
  

  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>

</head>


<body>

  <span class="mobile btn-mobile-menu">        
      <div class="nav_container">
         <nav class="nav-menu-item" style = "float:right">
            <i class="nav-menu-item">
              <a href="/#blog" title="" class="blog-button">  博客主页
              </a>
            </i>
            
                <i class="nav-menu-item">

                  <a href="/archive" title="archive" class="btn-mobile-menu__icon">
                      所有文章
                  </a>
                </i>
            
                <i class="nav-menu-item">

                  <a href="/tags" title="tags" class="btn-mobile-menu__icon">
                      分类
                  </a>
                </i>
            
                <i class="nav-menu-item">

                  <a href="/about" title="about" class="btn-mobile-menu__icon">
                      关于我
                  </a>
                </i>
            
          </nav>
          
      </div>
    </span> <header class="panel-cover panel-cover--collapsed" style="background-image: url('/images/background-cover.jpg')">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
      <div class="panel-main__content">
        <!-- 头像效果-start -->
        <div class="ih-item circle effect right_to_left">
          <a href="/#blog" title="前往 赵从亮区块链博客 的主页" class="blog-button">
            <div class="img"><img src="/images/avatar.jpg" alt="img"></div>
            <div class="info">
              <div class="info-back">
                <h2 style="font-size: 14px">
                   微信:13661944205 
                </h2>´
                <p style="font-size: 6px">
                   赵从亮 
                </p>
              </div>
            </div>
          </a>
        </div>
        <!-- 头像效果-end -->
        <h1 class="panel-cover__title panel-title"><a href="/#blog" title="link to homepage for 赵从亮区块链博客" class="blog-button">赵从亮区块链博客</a></h1>
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">赵从亮，区块链底层开发者、架构师。</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" /> 


        <div class="navigation-wrapper">
          <div>
            <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">博客主页</a></li>
                
                <li class="navigation__item"><a href="/archive" title="archive">所有文章</a></li>
                
                <li class="navigation__item"><a href="/tags" title="tags">分类</a></li>
                
                <li class="navigation__item"><a href="/about" title="about">关于我</a></li>
                
              </ul>
            </nav>
          </div>
        </div>

        <div style="display:flex;justify-content:center;-webkit-justify-content:center">
          <div style="display:flex;flex-direction:column;align-items:center;-webkit-flex-direction:column;-webkit-align-items:center;margin-right:10px">
            <img src="/images/zhishixingqiu.png" style="width:120px;height:120px;margin-top:30px;margin-bottom:10px" />
            <span class="panel-cover__subtitle panel-subtitle" style="font-size: 12px">请联系微信</span>
          </div>
          <div style="display:flex;flex-direction:column;align-items:center;-webkit-flex-direction:column;-webkit-align-items:center;margin-left:10px">
            <img src="/images/lianhu.jpg" style="width:120px;height:120px;margin-top:30px;margin-bottom:10px" />
            <span class="panel-cover__subtitle panel-subtitle" style="font-size: 12px">区块链公众号</span>
          </div>
        </div>

      </div>
    </div>
  </div>

  
  <div class="panel-cover--overlay cover-clear"></div>
  

  </div>
</header>


  <div class="content-wrapper">
    <div class="content-wrapper__inner">
      <article class="post-container post-container--single" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <h1 class="post-title">Go实现公链底层开发（四）</h1>
    <div class="post-meta">
      <img src="/images/calendar.png" width="20px"/>
      <time datetime="2017-08-20 00:00:00 +0800" itemprop="datePublished" class="post-meta__date date">2017-08-20</time>

      <!-- <span id="busuanzi_container_page_pv"> | 阅读：<span id="busuanzi_value_page_pv"></span>次</span> -->
    </p>
    </div>
  </header>

  <section class="post">
    <h2 id="交易1">交易（1）</h2>
<h2 id="引言">引言</h2>

<p>交易（transaction）是比特币的核心所在，而区块链唯一的目的，也正是为了能够安全可靠地存储交易。在区块链中，交易一旦被创建，就没有任何人能够再去修改或是删除它。今天，我们将会开始实现交易。不过，由于交易是很大的话题，我会把它分为两部分来讲：在今天这个部分，我们会实现交易的基本框架。在第二部分，我们会继续讨论它的一些细节。</p>

<p>由于比特币采用的是 UTXO 模型，并非账户模型，并不直接存在“余额”这个概念，余额需要通过遍历整个交易历史得来。</p>

<h2 id="比特币交易">比特币交易</h2>

<p>点击 <a href="https://blockchain.info/zh-cn/tx/b6f6b339b546a13822192b06ccbdd817afea5311845f769702ae2912f7d94ab5">这里</a> 在 blockchain.info 交易信息。
一笔交易由一些输入（input）和输出（output）组合而来：</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">Transaction</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">ID</span><span class="x">   </span><span class="p">[]</span><span class="kt">byte</span><span class="x">
	</span><span class="n">Vin</span><span class="x">  </span><span class="p">[]</span><span class="n">TXInput</span><span class="x">
	</span><span class="n">Vout</span><span class="x"> </span><span class="p">[]</span><span class="n">TXOutput</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p>对于每一笔新的交易，它的输入会引用（reference）之前一笔交易的输出（这里有个例外，coinbase 交易），引用就是花费的意思。所谓引用之前的一个输出，也就是将之前的一个输出包含在另一笔交易的输入当中，就是花费之前的交易输出。交易的输出，就是币实际存储的地方。下面的图示阐释了交易之间的互相关联：</p>

<p><img src="http://upload-images.jianshu.io/upload_images/127313-4f8e668c826fd31a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="the interconnection of transactions" /></p>

<p>注意：</p>

<ol>
  <li>有一些输出并没有被关联到某个输入上</li>
  <li>一笔交易的输入可以引用之前多笔交易的输出</li>
  <li>一个输入必须引用一个输出</li>
</ol>

<p>贯穿本文，我们将会使用像“钱（money）”，“币（coin）”，“花费（spend）”，“发送（send）”，“账户（account）” 等等这样的词。但是在比特币中，其实并不存在这样的概念。交易仅仅是通过一个脚本（script）来锁定（lock）一些值（value），而这些值只可以被锁定它们的人解锁（unlock）。</p>

<p>每一笔比特币交易都会创造输出，输出都会被区块链记录下来。给某个人发送比特币，实际上意味着创造新的 UTXO 并注册到那个人的地址，可以为他所用。</p>

<h2 id="交易输出">交易输出</h2>

<p>先从输出（output）开始：</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">TXOutput</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">Value</span><span class="x">        </span><span class="kt">int</span><span class="x">
	</span><span class="n">ScriptPubKey</span><span class="x"> </span><span class="kt">string</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p>输出主要包含两部分：</p>

<ol>
  <li>一定量的比特币(<code class="highlighter-rouge">Value</code>)</li>
  <li>一个锁定脚本(<code class="highlighter-rouge">ScriptPubKey</code>)，要花这笔钱，必须要解锁该脚本。</li>
</ol>

<p>实际上，正是输出里面存储了“币”（注意，也就是上面的 <code class="highlighter-rouge">Value</code> 字段）。而这里的存储，指的是用一个数学难题对输出进行锁定，这个难题被存储在 <code class="highlighter-rouge">ScriptPubKey</code> 里面。在内部，比特币使用了一个叫做 <em>Script</em> 的脚本语言，用它来定义锁定和解锁输出的逻辑。虽然这个语言相当的原始（这是为了避免潜在的黑客攻击和滥用而有意为之），并不复杂，但是我们也并不会在这里讨论它的细节。你可以在<a href="https://en.bitcoin.it/wiki/Script">这里</a> 找到详细解释。</p>

<blockquote>
  <p>在比特币中，<code class="highlighter-rouge">value</code> 字段存储的是 <em>satoshi</em> 的数量，而不是 BTC 的数量。一个 <em>satoshi</em> 等于一亿分之一的 BTC(0.00000001 BTC)，这也是比特币里面最小的货币单位（就像是 1 分的硬币）。</p>
</blockquote>

<p>由于还没有实现地址（address），所以目前我们会避免涉及逻辑相关的完整脚本。<code class="highlighter-rouge">ScriptPubKey</code> 将会存储一个任意的字符串（用户定义的钱包地址）。</p>

<blockquote>
  <p>顺便说一下，有了一个这样的脚本语言，也意味着比特币其实也可以作为一个智能合约平台。</p>
</blockquote>

<p>关于输出，非常重要的一点是：它们是<strong>不可再分的（indivisible）</strong>。也就是说，你无法仅引用它的其中某一部分。要么不用，如果要用，必须一次性用完。当一个新的交易中引用了某个输出，那么这个输出必须被全部花费。如果它的值比需要的值大，那么就会产生一个找零，找零会返还给发送方。这跟现实世界的场景十分类似，当你想要支付的时候，如果一个东西值 1 美元，而你给了一个 5 美元的纸币，那么你会得到一个 4 美元的找零。</p>

<h2 id="发送币">发送币</h2>

<p>现在，我们想要给其他人发送一些币。为此，我们需要创建一笔新的交易，将它放到一个块里，然后挖出这个块。之前我们只实现了 coinbase 交易（这是一种特殊的交易），现在我们需要一种通用的普通交易：</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">NewUTXOTransaction</span><span class="p">(</span><span class="n">from</span><span class="p">,</span><span class="x"> </span><span class="n">to</span><span class="x"> </span><span class="kt">string</span><span class="p">,</span><span class="x"> </span><span class="n">amount</span><span class="x"> </span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="n">bc</span><span class="x"> </span><span class="o">*</span><span class="n">Blockchain</span><span class="p">)</span><span class="x"> </span><span class="o">*</span><span class="n">Transaction</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="k">var</span><span class="x"> </span><span class="n">inputs</span><span class="x"> </span><span class="p">[]</span><span class="n">TXInput</span><span class="x">
	</span><span class="k">var</span><span class="x"> </span><span class="n">outputs</span><span class="x"> </span><span class="p">[]</span><span class="n">TXOutput</span><span class="x">

	</span><span class="n">acc</span><span class="p">,</span><span class="x"> </span><span class="n">validOutputs</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">bc</span><span class="o">.</span><span class="n">FindSpendableOutputs</span><span class="p">(</span><span class="n">from</span><span class="p">,</span><span class="x"> </span><span class="n">amount</span><span class="p">)</span><span class="x">

	</span><span class="k">if</span><span class="x"> </span><span class="n">acc</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="n">amount</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">log</span><span class="o">.</span><span class="n">Panic</span><span class="p">(</span><span class="s">"ERROR: Not enough funds"</span><span class="p">)</span><span class="x">
	</span><span class="p">}</span><span class="x">

	</span><span class="c">// Build a list of inputs</span><span class="x">
	</span><span class="k">for</span><span class="x"> </span><span class="n">txid</span><span class="p">,</span><span class="x"> </span><span class="n">outs</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">validOutputs</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">txID</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">hex</span><span class="o">.</span><span class="n">DecodeString</span><span class="p">(</span><span class="n">txid</span><span class="p">)</span><span class="x">

		</span><span class="k">for</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">out</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">outs</span><span class="x"> </span><span class="p">{</span><span class="x">
			</span><span class="n">input</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">TXInput</span><span class="p">{</span><span class="n">txID</span><span class="p">,</span><span class="x"> </span><span class="n">out</span><span class="p">,</span><span class="x"> </span><span class="n">from</span><span class="p">}</span><span class="x">
			</span><span class="n">inputs</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">append</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span><span class="x"> </span><span class="n">input</span><span class="p">)</span><span class="x">
		</span><span class="p">}</span><span class="x">
	</span><span class="p">}</span><span class="x">

	</span><span class="c">// Build a list of outputs</span><span class="x">
	</span><span class="n">outputs</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">append</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span><span class="x"> </span><span class="n">TXOutput</span><span class="p">{</span><span class="n">amount</span><span class="p">,</span><span class="x"> </span><span class="n">to</span><span class="p">})</span><span class="x">
	</span><span class="k">if</span><span class="x"> </span><span class="n">acc</span><span class="x"> </span><span class="o">&gt;</span><span class="x"> </span><span class="n">amount</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">outputs</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">append</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span><span class="x"> </span><span class="n">TXOutput</span><span class="p">{</span><span class="n">acc</span><span class="x"> </span><span class="o">-</span><span class="x"> </span><span class="n">amount</span><span class="p">,</span><span class="x"> </span><span class="n">from</span><span class="p">})</span><span class="x"> </span><span class="c">// a change</span><span class="x">
	</span><span class="p">}</span><span class="x">

	</span><span class="n">tx</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">Transaction</span><span class="p">{</span><span class="no">nil</span><span class="p">,</span><span class="x"> </span><span class="n">inputs</span><span class="p">,</span><span class="x"> </span><span class="n">outputs</span><span class="p">}</span><span class="x">
	</span><span class="n">tx</span><span class="o">.</span><span class="n">SetID</span><span class="p">()</span><span class="x">

	</span><span class="k">return</span><span class="x"> </span><span class="o">&amp;</span><span class="n">tx</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p>在创建新的输出前，我们首先必须找到所有的未花费输出，并且确保它们有足够的价值（value），这就是 <code class="highlighter-rouge">FindSpendableOutputs</code> 方法要做的事情。随后，对于每个找到的输出，会创建一个引用该输出的输入。接下来，我们创建两个输出：</p>

<ol>
  <li>
    <p>一个由接收者地址锁定。这是给其他地址实际转移的币。</p>
  </li>
  <li>
    <p>一个由发送者地址锁定。这是一个找零。只有当未花费输出超过新交易所需时产生。记住：输出是<strong>不可再分的</strong>。</p>
  </li>
</ol>

<p><code class="highlighter-rouge">FindSpendableOutputs</code> 方法基于之前定义的 <code class="highlighter-rouge">FindUnspentTransactions</code> 方法：</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">bc</span><span class="x"> </span><span class="o">*</span><span class="n">Blockchain</span><span class="p">)</span><span class="x"> </span><span class="n">FindSpendableOutputs</span><span class="p">(</span><span class="n">address</span><span class="x"> </span><span class="kt">string</span><span class="p">,</span><span class="x"> </span><span class="n">amount</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">unspentOutputs</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">int</span><span class="p">)</span><span class="x">
	</span><span class="n">unspentTXs</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">bc</span><span class="o">.</span><span class="n">FindUnspentTransactions</span><span class="p">(</span><span class="n">address</span><span class="p">)</span><span class="x">
	</span><span class="n">accumulated</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="x">

</span><span class="n">Work</span><span class="o">:</span><span class="x">
	</span><span class="k">for</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">tx</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">unspentTXs</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">txID</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">hex</span><span class="o">.</span><span class="n">EncodeToString</span><span class="p">(</span><span class="n">tx</span><span class="o">.</span><span class="n">ID</span><span class="p">)</span><span class="x">

		</span><span class="k">for</span><span class="x"> </span><span class="n">outIdx</span><span class="p">,</span><span class="x"> </span><span class="n">out</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">tx</span><span class="o">.</span><span class="n">Vout</span><span class="x"> </span><span class="p">{</span><span class="x">
			</span><span class="k">if</span><span class="x"> </span><span class="n">out</span><span class="o">.</span><span class="n">CanBeUnlockedWith</span><span class="p">(</span><span class="n">address</span><span class="p">)</span><span class="x"> </span><span class="o">&amp;&amp;</span><span class="x"> </span><span class="n">accumulated</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="n">amount</span><span class="x"> </span><span class="p">{</span><span class="x">
				</span><span class="n">accumulated</span><span class="x"> </span><span class="o">+=</span><span class="x"> </span><span class="n">out</span><span class="o">.</span><span class="n">Value</span><span class="x">
				</span><span class="n">unspentOutputs</span><span class="p">[</span><span class="n">txID</span><span class="p">]</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">append</span><span class="p">(</span><span class="n">unspentOutputs</span><span class="p">[</span><span class="n">txID</span><span class="p">],</span><span class="x"> </span><span class="n">outIdx</span><span class="p">)</span><span class="x">

				</span><span class="k">if</span><span class="x"> </span><span class="n">accumulated</span><span class="x"> </span><span class="o">&gt;=</span><span class="x"> </span><span class="n">amount</span><span class="x"> </span><span class="p">{</span><span class="x">
					</span><span class="k">break</span><span class="x"> </span><span class="n">Work</span><span class="x">
				</span><span class="p">}</span><span class="x">
			</span><span class="p">}</span><span class="x">
		</span><span class="p">}</span><span class="x">
	</span><span class="p">}</span><span class="x">

	</span><span class="k">return</span><span class="x"> </span><span class="n">accumulated</span><span class="p">,</span><span class="x"> </span><span class="n">unspentOutputs</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p>这个方法对所有的未花费交易进行迭代，并对它的值进行累加。当累加值大于或等于我们想要传送的值时，它就会停止并返回累加值，同时返回的还有通过交易 ID 进行分组的输出索引。我们只需取出足够支付的钱就够了。</p>

<p>现在，我们可以修改 <code class="highlighter-rouge">Blockchain.MineBlock</code> 方法：</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">bc</span><span class="x"> </span><span class="o">*</span><span class="n">Blockchain</span><span class="p">)</span><span class="x"> </span><span class="n">MineBlock</span><span class="p">(</span><span class="n">transactions</span><span class="x"> </span><span class="p">[]</span><span class="o">*</span><span class="n">Transaction</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="o">...</span><span class="x">
	</span><span class="n">newBlock</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">NewBlock</span><span class="p">(</span><span class="n">transactions</span><span class="p">,</span><span class="x"> </span><span class="n">lastHash</span><span class="p">)</span><span class="x">
	</span><span class="o">...</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p>最后，让我们来实现 <code class="highlighter-rouge">send</code> 方法：</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">cli</span><span class="x"> </span><span class="o">*</span><span class="n">CLI</span><span class="p">)</span><span class="x"> </span><span class="n">send</span><span class="p">(</span><span class="n">from</span><span class="p">,</span><span class="x"> </span><span class="n">to</span><span class="x"> </span><span class="kt">string</span><span class="p">,</span><span class="x"> </span><span class="n">amount</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">bc</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">NewBlockchain</span><span class="p">(</span><span class="n">from</span><span class="p">)</span><span class="x">
	</span><span class="k">defer</span><span class="x"> </span><span class="n">bc</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span><span class="x">

	</span><span class="n">tx</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">NewUTXOTransaction</span><span class="p">(</span><span class="n">from</span><span class="p">,</span><span class="x"> </span><span class="n">to</span><span class="p">,</span><span class="x"> </span><span class="n">amount</span><span class="p">,</span><span class="x"> </span><span class="n">bc</span><span class="p">)</span><span class="x">
	</span><span class="n">bc</span><span class="o">.</span><span class="n">MineBlock</span><span class="p">([]</span><span class="o">*</span><span class="n">Transaction</span><span class="p">{</span><span class="n">tx</span><span class="p">})</span><span class="x">
	</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Success!"</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p>发送币意味着创建新的交易，并通过挖出新块的方式将交易打包到区块链中。不过，比特币并不是一连串立刻完成这些事情（虽然我们目前的实现是这么做的）。相反，它会将所有新的交易放到一个内存池中（mempool），然后当矿工准备挖出一个新块时，它就从内存池中取出所有交易，创建一个候选块。只有当包含这些交易的块被挖出来，并添加到区块链以后，里面的交易才开始确认。</p>

<p>让我们来检查一下发送币是否能工作：</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>blockchain_go send -from Ivan -to Pedro -amount 6
00000001b56d60f86f72ab2a59fadb197d767b97d4873732be505e0a65cc1e37

Success!

<span class="gp">$ </span>blockchain_go getbalance -address Ivan
Balance of <span class="s1">'Ivan'</span>: 4

<span class="gp">$ </span>blockchain_go getbalance -address Pedro
Balance of <span class="s1">'Pedro'</span>: 6
</code></pre>
</div>

<p>很好！现在，让我们创建更多的交易，确保从多个输出中发送币也正常工作：</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>blockchain_go send -from Pedro -to Helen -amount 2
00000099938725eb2c7730844b3cd40209d46bce2c2af9d87c2b7611fe9d5bdf

Success!

<span class="gp">$ </span>blockchain_go send -from Ivan -to Helen -amount 2
000000a2edf94334b1d94f98d22d7e4c973261660397dc7340464f7959a7a9aa

Success!
</code></pre>
</div>

<p>现在，Helen 的币被锁定在了两个输出中：一个来自 Pedro，一个来自 Ivan。让我们把它们发送给其他人：</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>blockchain_go send -from Helen -to Rachel -amount 3
000000c58136cffa669e767b8f881d16e2ede3974d71df43058baaf8c069f1a0

Success!

<span class="gp">$ </span>blockchain_go getbalance -address Ivan
Balance of <span class="s1">'Ivan'</span>: 2

<span class="gp">$ </span>blockchain_go getbalance -address Pedro
Balance of <span class="s1">'Pedro'</span>: 4

<span class="gp">$ </span>blockchain_go getbalance -address Helen
Balance of <span class="s1">'Helen'</span>: 1

<span class="gp">$ </span>blockchain_go getbalance -address Rachel
Balance of <span class="s1">'Rachel'</span>: 3
</code></pre>
</div>

<p>看起来没问题！现在，来测试一些失败的情况：</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>blockchain_go send -from Pedro -to Ivan -amount 5
panic: ERROR: Not enough funds

<span class="gp">$ </span>blockchain_go getbalance -address Pedro
Balance of <span class="s1">'Pedro'</span>: 4

<span class="gp">$ </span>blockchain_go getbalance -address Ivan
Balance of <span class="s1">'Ivan'</span>: 2
</code></pre>
</div>

<h2 id="总结">总结</h2>

<p>虽然不容易，但是现在终于实现交易了！不过，我们依然缺少了一些像比特币那样的一些关键特性：</p>

<ol>
  <li>
    <p>地址（address）。我们还没有基于私钥（private key）的真实地址。</p>
  </li>
  <li>
    <p>奖励（reward）。现在挖矿是肯定无法盈利的！</p>
  </li>
  <li>
    <p>UTXO 集。获取余额需要扫描整个区块链，而当区块非常多的时候，这么做就会花费很长时间。并且，如果我们想要验证后续交易，也需要花费很长时间。而 UTXO 集就是为了解决这些问题，加快交易相关的操作。</p>
  </li>
  <li>
    <p>内存池（mempool）。在交易被打包到块之前，这些交易被存储在内存池里面。在我们目前的实现中，一个块仅仅包含一笔交易，这是相当低效的。</p>
  </li>
</ol>

<h2 id="交易输入">交易输入</h2>

<p>这里是输入：</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">TXInput</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">Txid</span><span class="x">      </span><span class="p">[]</span><span class="kt">byte</span><span class="x">
	</span><span class="n">Vout</span><span class="x">      </span><span class="kt">int</span><span class="x">
	</span><span class="n">ScriptSig</span><span class="x"> </span><span class="kt">string</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p>正如之前所提到的，一个输入引用了之前交易的一个输出：<code class="highlighter-rouge">Txid</code> 存储的是之前交易的 ID，<code class="highlighter-rouge">Vout</code> 存储的是该输出在那笔交易中所有输出的索引（因为一笔交易可能有多个输出，需要有信息指明是具体的哪一个）。<code class="highlighter-rouge">ScriptSig</code> 是一个脚本，提供了可解锁输出结构里面 <code class="highlighter-rouge">ScriptPubKey</code> 字段的数据。如果 <code class="highlighter-rouge">ScriptSig</code> 提供的数据是正确的，那么输出就会被解锁，然后被解锁的值就可以被用于产生新的输出；如果数据不正确，输出就无法被引用在输入中，或者说，无法使用这个输出。这种机制，保证了用户无法花费属于其他人的币。</p>

<p>再次强调，由于我们还没有实现地址，所以目前 <code class="highlighter-rouge">ScriptSig</code> 将仅仅存储一个用户自定义的任意钱包地址。我们会在下一篇文章中实现公钥（public key）和签名（signature）。</p>

<p>来简要总结一下。输出，就是 “币” 存储的地方。每个输出都会带有一个解锁脚本，这个脚本定义了解锁该输出的逻辑。每笔新的交易，必须至少有一个输入和输出。一个输入引用了之前一笔交易的输出，并提供了解锁数据（也就是 <code class="highlighter-rouge">ScriptSig</code> 字段），该数据会被用在输出的解锁脚本中解锁输出，解锁完成后即可使用它的值去产生新的输出。</p>

<p>每一笔输入都是之前一笔交易的输出，那么假设从某一笔交易开始不断往前追溯，它所涉及的输入和输出到底是谁先存在呢？换个说法，这是个鸡和蛋谁先谁后的问题，是先有蛋还是先有鸡呢？</p>

<h2 id="先有蛋">先有蛋</h2>

<p>在比特币中，是先有蛋，然后才有鸡。输入引用输出的逻辑，是经典的“蛋还是鸡”问题：输入先产生输出，然后输出使得输入成为可能。在比特币中，最先有输出，然后才有输入。换而言之，第一笔交易只有输出，没有输入。</p>

<p>当矿工挖出一个新的块时，它会向新的块中添加一个 <strong>coinbase</strong> 交易。coinbase 交易是一种特殊的交易，它不需要引用之前一笔交易的输出。它“凭空”产生了币（也就是产生了新币），这是矿工获得挖出新块的奖励，也可以理解为“发行新币”。</p>

<p>在区块链的最初，也就是第一个块，叫做创世块。正是这个创世块，产生了区块链最开始的输出。对于创世块，不需要引用之前的交易输出。因为在创世块之前根本不存在交易，也就没有不存在交易输出。</p>

<p>来创建一个 coinbase 交易：</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">NewCoinbaseTX</span><span class="p">(</span><span class="n">to</span><span class="p">,</span><span class="x"> </span><span class="n">data</span><span class="x"> </span><span class="kt">string</span><span class="p">)</span><span class="x"> </span><span class="o">*</span><span class="n">Transaction</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="k">if</span><span class="x"> </span><span class="n">data</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="s">""</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">data</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"Reward to '%s'"</span><span class="p">,</span><span class="x"> </span><span class="n">to</span><span class="p">)</span><span class="x">
	</span><span class="p">}</span><span class="x">

	</span><span class="n">txin</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">TXInput</span><span class="p">{[]</span><span class="kt">byte</span><span class="p">{},</span><span class="x"> </span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="x"> </span><span class="n">data</span><span class="p">}</span><span class="x">
	</span><span class="n">txout</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">TXOutput</span><span class="p">{</span><span class="n">subsidy</span><span class="p">,</span><span class="x"> </span><span class="n">to</span><span class="p">}</span><span class="x">
	</span><span class="n">tx</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">Transaction</span><span class="p">{</span><span class="no">nil</span><span class="p">,</span><span class="x"> </span><span class="p">[]</span><span class="n">TXInput</span><span class="p">{</span><span class="n">txin</span><span class="p">},</span><span class="x"> </span><span class="p">[]</span><span class="n">TXOutput</span><span class="p">{</span><span class="n">txout</span><span class="p">}}</span><span class="x">
	</span><span class="n">tx</span><span class="o">.</span><span class="n">SetID</span><span class="p">()</span><span class="x">

	</span><span class="k">return</span><span class="x"> </span><span class="o">&amp;</span><span class="n">tx</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p>coinbase 交易只有一个输出，没有输入。在我们的实现中，它表现为 <code class="highlighter-rouge">Txid</code> 为空，<code class="highlighter-rouge">Vout</code> 等于 -1。并且，在当前实现中，coinbase 交易也没有在 <code class="highlighter-rouge">ScriptSig</code> 中存储脚本，而只是存储了一个任意的字符串 <code class="highlighter-rouge">data</code>。</p>

<blockquote>
  <p>在比特币中，第一笔 coinbase 交易包含了如下信息：“The Times 03/Jan/2009 Chancellor on brink of second bailout for banks”。<a href="https://blockchain.info/tx/4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b?show_adv=true">可点击这里查看</a>.</p>
</blockquote>

<p><code class="highlighter-rouge">subsidy</code> 是挖出新块的奖励金。在比特币中，实际并没有存储这个数字，而是基于区块总数进行计算而得：区块总数除以 210000 就是 <code class="highlighter-rouge">subsidy</code>。挖出创世块的奖励是 50 BTC，每挖出 <code class="highlighter-rouge">210000</code> 个块后，奖励减半。在我们的实现中，这个奖励值将会是一个常量（至少目前是）。</p>

<h2 id="将交易保存到区块链">将交易保存到区块链</h2>

<p>从现在开始，每个块必须存储至少一笔交易。如果没有交易，也就不可能出新的块。这意味着我们应该移除 <code class="highlighter-rouge">Block</code> 的 <code class="highlighter-rouge">Data</code> 字段，取而代之的是存储交易：</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">Block</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">Timestamp</span><span class="x">     </span><span class="kt">int64</span><span class="x">
	</span><span class="n">Transactions</span><span class="x">  </span><span class="p">[]</span><span class="o">*</span><span class="n">Transaction</span><span class="x">
	</span><span class="n">PrevBlockHash</span><span class="x"> </span><span class="p">[]</span><span class="kt">byte</span><span class="x">
	</span><span class="n">Hash</span><span class="x">          </span><span class="p">[]</span><span class="kt">byte</span><span class="x">
	</span><span class="n">Nonce</span><span class="x">         </span><span class="kt">int</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p><code class="highlighter-rouge">NewBlock</code> 和 <code class="highlighter-rouge">NewGenesisBlock</code> 也必须做出相应改变：</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">NewBlock</span><span class="p">(</span><span class="n">transactions</span><span class="x"> </span><span class="p">[]</span><span class="o">*</span><span class="n">Transaction</span><span class="p">,</span><span class="x"> </span><span class="n">prevBlockHash</span><span class="x"> </span><span class="p">[]</span><span class="kt">byte</span><span class="p">)</span><span class="x"> </span><span class="o">*</span><span class="n">Block</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">block</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="o">&amp;</span><span class="n">Block</span><span class="p">{</span><span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">Unix</span><span class="p">(),</span><span class="x"> </span><span class="n">transactions</span><span class="p">,</span><span class="x"> </span><span class="n">prevBlockHash</span><span class="p">,</span><span class="x"> </span><span class="p">[]</span><span class="kt">byte</span><span class="p">{},</span><span class="x"> </span><span class="m">0</span><span class="p">}</span><span class="x">
	</span><span class="o">...</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">NewGenesisBlock</span><span class="p">(</span><span class="n">coinbase</span><span class="x"> </span><span class="o">*</span><span class="n">Transaction</span><span class="p">)</span><span class="x"> </span><span class="o">*</span><span class="n">Block</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="k">return</span><span class="x"> </span><span class="n">NewBlock</span><span class="p">([]</span><span class="o">*</span><span class="n">Transaction</span><span class="p">{</span><span class="n">coinbase</span><span class="p">},</span><span class="x"> </span><span class="p">[]</span><span class="kt">byte</span><span class="p">{})</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p>接下来修改创建区块链的函数：</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">CreateBlockchain</span><span class="p">(</span><span class="n">address</span><span class="x"> </span><span class="kt">string</span><span class="p">)</span><span class="x"> </span><span class="o">*</span><span class="n">Blockchain</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="o">...</span><span class="x">
	</span><span class="n">err</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">db</span><span class="o">.</span><span class="n">Update</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">tx</span><span class="x"> </span><span class="o">*</span><span class="n">bolt</span><span class="o">.</span><span class="n">Tx</span><span class="p">)</span><span class="x"> </span><span class="kt">error</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">cbtx</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">NewCoinbaseTX</span><span class="p">(</span><span class="n">address</span><span class="p">,</span><span class="x"> </span><span class="n">genesisCoinbaseData</span><span class="p">)</span><span class="x">
		</span><span class="n">genesis</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">NewGenesisBlock</span><span class="p">(</span><span class="n">cbtx</span><span class="p">)</span><span class="x">

		</span><span class="n">b</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">tx</span><span class="o">.</span><span class="n">CreateBucket</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="n">blocksBucket</span><span class="p">))</span><span class="x">
		</span><span class="n">err</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">b</span><span class="o">.</span><span class="n">Put</span><span class="p">(</span><span class="n">genesis</span><span class="o">.</span><span class="n">Hash</span><span class="p">,</span><span class="x"> </span><span class="n">genesis</span><span class="o">.</span><span class="n">Serialize</span><span class="p">())</span><span class="x">
		</span><span class="o">...</span><span class="x">
	</span><span class="p">})</span><span class="x">
	</span><span class="o">...</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p>现在，这个函数会接受一个地址作为参数，这个地址将会被用来接收挖出创世块的奖励。</p>

<h2 id="工作量证明">工作量证明</h2>

<p>工作量证明算法必须要将存储在区块里面的交易考虑进去，从而保证区块链交易存储的一致性和可靠性。所以，我们必须修改 <code class="highlighter-rouge">ProofOfWork.prepareData</code> 方法：</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">pow</span><span class="x"> </span><span class="o">*</span><span class="n">ProofOfWork</span><span class="p">)</span><span class="x"> </span><span class="n">prepareData</span><span class="p">(</span><span class="n">nonce</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="p">[]</span><span class="kt">byte</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">data</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">bytes</span><span class="o">.</span><span class="n">Join</span><span class="p">(</span><span class="x">
		</span><span class="p">[][]</span><span class="kt">byte</span><span class="p">{</span><span class="x">
			</span><span class="n">pow</span><span class="o">.</span><span class="n">block</span><span class="o">.</span><span class="n">PrevBlockHash</span><span class="p">,</span><span class="x">
			</span><span class="n">pow</span><span class="o">.</span><span class="n">block</span><span class="o">.</span><span class="n">HashTransactions</span><span class="p">(),</span><span class="x"> </span><span class="c">// This line was changed</span><span class="x">
			</span><span class="n">IntToHex</span><span class="p">(</span><span class="n">pow</span><span class="o">.</span><span class="n">block</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">),</span><span class="x">
			</span><span class="n">IntToHex</span><span class="p">(</span><span class="kt">int64</span><span class="p">(</span><span class="n">targetBits</span><span class="p">)),</span><span class="x">
			</span><span class="n">IntToHex</span><span class="p">(</span><span class="kt">int64</span><span class="p">(</span><span class="n">nonce</span><span class="p">)),</span><span class="x">
		</span><span class="p">},</span><span class="x">
		</span><span class="p">[]</span><span class="kt">byte</span><span class="p">{},</span><span class="x">
	</span><span class="p">)</span><span class="x">

	</span><span class="k">return</span><span class="x"> </span><span class="n">data</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p>不像之前使用 <code class="highlighter-rouge">pow.block.Data</code>，现在我们使用 <code class="highlighter-rouge">pow.block.HashTransactions()</code> ：</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">b</span><span class="x"> </span><span class="o">*</span><span class="n">Block</span><span class="p">)</span><span class="x"> </span><span class="n">HashTransactions</span><span class="p">()</span><span class="x"> </span><span class="p">[]</span><span class="kt">byte</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="k">var</span><span class="x"> </span><span class="n">txHashes</span><span class="x"> </span><span class="p">[][]</span><span class="kt">byte</span><span class="x">
	</span><span class="k">var</span><span class="x"> </span><span class="n">txHash</span><span class="x"> </span><span class="p">[</span><span class="m">32</span><span class="p">]</span><span class="kt">byte</span><span class="x">

	</span><span class="k">for</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">tx</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">b</span><span class="o">.</span><span class="n">Transactions</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">txHashes</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">append</span><span class="p">(</span><span class="n">txHashes</span><span class="p">,</span><span class="x"> </span><span class="n">tx</span><span class="o">.</span><span class="n">ID</span><span class="p">)</span><span class="x">
	</span><span class="p">}</span><span class="x">
	</span><span class="n">txHash</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">sha256</span><span class="o">.</span><span class="n">Sum256</span><span class="p">(</span><span class="n">bytes</span><span class="o">.</span><span class="n">Join</span><span class="p">(</span><span class="n">txHashes</span><span class="p">,</span><span class="x"> </span><span class="p">[]</span><span class="kt">byte</span><span class="p">{}))</span><span class="x">

	</span><span class="k">return</span><span class="x"> </span><span class="n">txHash</span><span class="p">[</span><span class="o">:</span><span class="p">]</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p>通过哈希提供数据的唯一表示，这种做法我们已经不是第一次遇到了。我们想要通过仅仅一个哈希，就可以识别一个块里面的所有交易。为此，先获得每笔交易的哈希，然后将它们关联起来，最后获得一个连接后的组合哈希。</p>

<blockquote>
  <p>比特币使用了一个更加复杂的技术：它将一个块里面包含的所有交易表示为一个  <a href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle tree</a> ，然后在工作量证明系统中使用树的根哈希（root hash）。这个方法能够让我们快速检索一个块里面是否包含了某笔交易，即只需 root hash 而无需下载所有交易即可完成判断。</p>
</blockquote>

<p>来检查一下到目前为止是否正确：</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>blockchain_go createblockchain -address Ivan
00000093450837f8b52b78c25f8163bb6137caf43ff4d9a01d1b731fa8ddcc8a

Done!
</code></pre>
</div>

<p>很好！我们已经获得了第一笔挖矿奖励，但是，我们要如何查看余额呢？</p>

<h2 id="未花费交易输出">未花费交易输出</h2>

<p>我们需要找到所有的未花费交易输出（unspent transactions outputs, UTXO）。<strong>未花费（unspent）</strong> 指的是这个输出还没有被包含在任何交易的输入中，或者说没有被任何输入引用。在上面的图示中，未花费的输出是：</p>

<ol>
  <li>tx0, output 1;</li>
  <li>tx1, output 0;</li>
  <li>tx3, output 0;</li>
  <li>tx4, output 0.</li>
</ol>

<p>当然了，检查余额时，我们并不需要知道整个区块链上所有的 UTXO，只需要关注那些我们能够解锁的那些 UTXO（目前我们还没有实现密钥，所以我们将会使用用户定义的地址来代替）。首先，让我们定义在输入和输出上的锁定和解锁方法：</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">in</span><span class="x"> </span><span class="o">*</span><span class="n">TXInput</span><span class="p">)</span><span class="x"> </span><span class="n">CanUnlockOutputWith</span><span class="p">(</span><span class="n">unlockingData</span><span class="x"> </span><span class="kt">string</span><span class="p">)</span><span class="x"> </span><span class="kt">bool</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="k">return</span><span class="x"> </span><span class="n">in</span><span class="o">.</span><span class="n">ScriptSig</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="n">unlockingData</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">out</span><span class="x"> </span><span class="o">*</span><span class="n">TXOutput</span><span class="p">)</span><span class="x"> </span><span class="n">CanBeUnlockedWith</span><span class="p">(</span><span class="n">unlockingData</span><span class="x"> </span><span class="kt">string</span><span class="p">)</span><span class="x"> </span><span class="kt">bool</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="k">return</span><span class="x"> </span><span class="n">out</span><span class="o">.</span><span class="n">ScriptPubKey</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="n">unlockingData</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p>在这里，我们只是将 script 字段与 <code class="highlighter-rouge">unlockingData</code> 进行了比较。在后续文章我们基于私钥实现了地址以后，会对这部分进行改进。</p>

<p>下一步，找到包含未花费输出的交易，这一步其实相当困难：</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">bc</span><span class="x"> </span><span class="o">*</span><span class="n">Blockchain</span><span class="p">)</span><span class="x"> </span><span class="n">FindUnspentTransactions</span><span class="p">(</span><span class="n">address</span><span class="x"> </span><span class="kt">string</span><span class="p">)</span><span class="x"> </span><span class="p">[]</span><span class="n">Transaction</span><span class="x"> </span><span class="p">{</span><span class="x">
  </span><span class="k">var</span><span class="x"> </span><span class="n">unspentTXs</span><span class="x"> </span><span class="p">[]</span><span class="n">Transaction</span><span class="x">
  </span><span class="n">spentTXOs</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">int</span><span class="p">)</span><span class="x">
  </span><span class="n">bci</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">bc</span><span class="o">.</span><span class="n">Iterator</span><span class="p">()</span><span class="x">

  </span><span class="k">for</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">block</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">bci</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span><span class="x">

    </span><span class="k">for</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">tx</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">block</span><span class="o">.</span><span class="n">Transactions</span><span class="x"> </span><span class="p">{</span><span class="x">
      </span><span class="n">txID</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">hex</span><span class="o">.</span><span class="n">EncodeToString</span><span class="p">(</span><span class="n">tx</span><span class="o">.</span><span class="n">ID</span><span class="p">)</span><span class="x">

    </span><span class="n">Outputs</span><span class="o">:</span><span class="x">
      </span><span class="k">for</span><span class="x"> </span><span class="n">outIdx</span><span class="p">,</span><span class="x"> </span><span class="n">out</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">tx</span><span class="o">.</span><span class="n">Vout</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="c">// Was the output spent?</span><span class="x">
        </span><span class="k">if</span><span class="x"> </span><span class="n">spentTXOs</span><span class="p">[</span><span class="n">txID</span><span class="p">]</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
          </span><span class="k">for</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">spentOut</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">spentTXOs</span><span class="p">[</span><span class="n">txID</span><span class="p">]</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="k">if</span><span class="x"> </span><span class="n">spentOut</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="n">outIdx</span><span class="x"> </span><span class="p">{</span><span class="x">
              </span><span class="k">continue</span><span class="x"> </span><span class="n">Outputs</span><span class="x">
            </span><span class="p">}</span><span class="x">
          </span><span class="p">}</span><span class="x">
        </span><span class="p">}</span><span class="x">

        </span><span class="k">if</span><span class="x"> </span><span class="n">out</span><span class="o">.</span><span class="n">CanBeUnlockedWith</span><span class="p">(</span><span class="n">address</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
          </span><span class="n">unspentTXs</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">append</span><span class="p">(</span><span class="n">unspentTXs</span><span class="p">,</span><span class="x"> </span><span class="o">*</span><span class="n">tx</span><span class="p">)</span><span class="x">
        </span><span class="p">}</span><span class="x">
      </span><span class="p">}</span><span class="x">

      </span><span class="k">if</span><span class="x"> </span><span class="n">tx</span><span class="o">.</span><span class="n">IsCoinbase</span><span class="p">()</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="no">false</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">for</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">in</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">tx</span><span class="o">.</span><span class="n">Vin</span><span class="x"> </span><span class="p">{</span><span class="x">
          </span><span class="k">if</span><span class="x"> </span><span class="n">in</span><span class="o">.</span><span class="n">CanUnlockOutputWith</span><span class="p">(</span><span class="n">address</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="n">inTxID</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">hex</span><span class="o">.</span><span class="n">EncodeToString</span><span class="p">(</span><span class="n">in</span><span class="o">.</span><span class="n">Txid</span><span class="p">)</span><span class="x">
            </span><span class="n">spentTXOs</span><span class="p">[</span><span class="n">inTxID</span><span class="p">]</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">append</span><span class="p">(</span><span class="n">spentTXOs</span><span class="p">[</span><span class="n">inTxID</span><span class="p">],</span><span class="x"> </span><span class="n">in</span><span class="o">.</span><span class="n">Vout</span><span class="p">)</span><span class="x">
          </span><span class="p">}</span><span class="x">
        </span><span class="p">}</span><span class="x">
      </span><span class="p">}</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="k">if</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">PrevBlockHash</span><span class="p">)</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="m">0</span><span class="x"> </span><span class="p">{</span><span class="x">
      </span><span class="k">break</span><span class="x">
    </span><span class="p">}</span><span class="x">
  </span><span class="p">}</span><span class="x">

  </span><span class="k">return</span><span class="x"> </span><span class="n">unspentTXs</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p>由于交易被存储在区块里，所以我们不得不检查区块链里的每一笔交易。从输出开始：</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">if</span><span class="x"> </span><span class="n">out</span><span class="o">.</span><span class="n">CanBeUnlockedWith</span><span class="p">(</span><span class="n">address</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">unspentTXs</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">append</span><span class="p">(</span><span class="n">unspentTXs</span><span class="p">,</span><span class="x"> </span><span class="n">tx</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p>如果一个输出被一个地址锁定，并且这个地址恰好是我们要找的地址，那么这个输出就是我们想要的。不过在获取它之前，我们需要检查该输出是否已经被包含在一个交易的输入中，也就是检查它是否已经被花费了：</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">if</span><span class="x"> </span><span class="n">spentTXOs</span><span class="p">[</span><span class="n">txID</span><span class="p">]</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="k">for</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">spentOut</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">spentTXOs</span><span class="p">[</span><span class="n">txID</span><span class="p">]</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="k">if</span><span class="x"> </span><span class="n">spentOut</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="n">outIdx</span><span class="x"> </span><span class="p">{</span><span class="x">
			</span><span class="k">continue</span><span class="x"> </span><span class="n">Outputs</span><span class="x">
		</span><span class="p">}</span><span class="x">
	</span><span class="p">}</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p>我们跳过那些已经被包含在其他输入中的输出（这说明这个输出已经被花费，无法再用了）。检查完输出以后，我们将给定地址所有能够解锁输出的输入聚集起来（这并不适用于 coinbase 交易，因为它们不解锁输出）：</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">if</span><span class="x"> </span><span class="n">tx</span><span class="o">.</span><span class="n">IsCoinbase</span><span class="p">()</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="no">false</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">for</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">in</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">tx</span><span class="o">.</span><span class="n">Vin</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">if</span><span class="x"> </span><span class="n">in</span><span class="o">.</span><span class="n">CanUnlockOutputWith</span><span class="p">(</span><span class="n">address</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="n">inTxID</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">hex</span><span class="o">.</span><span class="n">EncodeToString</span><span class="p">(</span><span class="n">in</span><span class="o">.</span><span class="n">Txid</span><span class="p">)</span><span class="x">
            </span><span class="n">spentTXOs</span><span class="p">[</span><span class="n">inTxID</span><span class="p">]</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">append</span><span class="p">(</span><span class="n">spentTXOs</span><span class="p">[</span><span class="n">inTxID</span><span class="p">],</span><span class="x"> </span><span class="n">in</span><span class="o">.</span><span class="n">Vout</span><span class="p">)</span><span class="x">
        </span><span class="p">}</span><span class="x">
    </span><span class="p">}</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p>这个函数返回了一个交易列表，里面包含了未花费输出。为了计算余额，我们还需要一个函数将这些交易作为输入，然后仅返回一个输出：</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">bc</span><span class="x"> </span><span class="o">*</span><span class="n">Blockchain</span><span class="p">)</span><span class="x"> </span><span class="n">FindUTXO</span><span class="p">(</span><span class="n">address</span><span class="x"> </span><span class="kt">string</span><span class="p">)</span><span class="x"> </span><span class="p">[]</span><span class="n">TXOutput</span><span class="x"> </span><span class="p">{</span><span class="x">
       </span><span class="k">var</span><span class="x"> </span><span class="n">UTXOs</span><span class="x"> </span><span class="p">[]</span><span class="n">TXOutput</span><span class="x">
       </span><span class="n">unspentTransactions</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">bc</span><span class="o">.</span><span class="n">FindUnspentTransactions</span><span class="p">(</span><span class="n">address</span><span class="p">)</span><span class="x">

       </span><span class="k">for</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">tx</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">unspentTransactions</span><span class="x"> </span><span class="p">{</span><span class="x">
               </span><span class="k">for</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">out</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">tx</span><span class="o">.</span><span class="n">Vout</span><span class="x"> </span><span class="p">{</span><span class="x">
                       </span><span class="k">if</span><span class="x"> </span><span class="n">out</span><span class="o">.</span><span class="n">CanBeUnlockedWith</span><span class="p">(</span><span class="n">address</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
                               </span><span class="n">UTXOs</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">append</span><span class="p">(</span><span class="n">UTXOs</span><span class="p">,</span><span class="x"> </span><span class="n">out</span><span class="p">)</span><span class="x">
                       </span><span class="p">}</span><span class="x">
               </span><span class="p">}</span><span class="x">
       </span><span class="p">}</span><span class="x">

       </span><span class="k">return</span><span class="x"> </span><span class="n">UTXOs</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p>就是这么多了！现在我们来实现 <code class="highlighter-rouge">getbalance</code> 命令：</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">cli</span><span class="x"> </span><span class="o">*</span><span class="n">CLI</span><span class="p">)</span><span class="x"> </span><span class="n">getBalance</span><span class="p">(</span><span class="n">address</span><span class="x"> </span><span class="kt">string</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">bc</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">NewBlockchain</span><span class="p">(</span><span class="n">address</span><span class="p">)</span><span class="x">
	</span><span class="k">defer</span><span class="x"> </span><span class="n">bc</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span><span class="x">

	</span><span class="n">balance</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="x">
	</span><span class="n">UTXOs</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">bc</span><span class="o">.</span><span class="n">FindUTXO</span><span class="p">(</span><span class="n">address</span><span class="p">)</span><span class="x">

	</span><span class="k">for</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">out</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">UTXOs</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">balance</span><span class="x"> </span><span class="o">+=</span><span class="x"> </span><span class="n">out</span><span class="o">.</span><span class="n">Value</span><span class="x">
	</span><span class="p">}</span><span class="x">

	</span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Balance of '%s': %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="x"> </span><span class="n">address</span><span class="p">,</span><span class="x"> </span><span class="n">balance</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p>账户余额就是由账户地址锁定的所有未花费交易输出的总和。</p>

<p>在挖出创世块以后，来检查一下我们的余额：</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>blockchain_go getbalance -address Ivan
Balance of <span class="s1">'Ivan'</span>: 10
</code></pre>
</div>

<p>这就是我们的第一笔钱！</p>

<p>参考:</p>

<p>[1] <a href="https://github.com/Jeiwan/blockchain_go/tree/part_4">Full source codes</a></p>

<p>[2] <a href="https://en.bitcoin.it/wiki/Transaction">Transaction</a></p>

<p>[3] <a href="https://en.bitcoin.it/wiki/Protocol_documentation#Merkle_Trees">Merkle tree</a></p>

<p>[4] <a href="https://en.bitcoin.it/wiki/Coinbase">Coinbase</a></p>

<p>[5] <a href="https://github.com/Jeiwan/blockchain_go/tree/part_4">part_4</a></p>

<p>[6] <a href="https://jeiwan.cc/posts/building-blockchain-in-go-part-4/">Building Blockchain in Go. Part 4: Transactions 1</a></p>

<hr />
<p>文章转自：<a href="https://github.com/liuchengxu/blockchain-tutorial">https://github.com/liuchengxu/blockchain-tutorial</a>
原文翻译自：<a href="https://jeiwan.cc/posts/building-blockchain-in-go-part-4/">https://jeiwan.cc/posts/building-blockchain-in-go-part-1/</a></p>


  </section>
  <h3 style="color:red"><strong>版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请联系：13661944205</strong></h3>
  <h3 style="color:black"><strong>打赏以太币请博主喝咖啡：0xE49265DD6c9E2073b27ED3428887E29Ee37Ba318</strong></h3>
</article>

<section>

            <div class="content-play">
              <p><a href="javascript:void(0)" onclick="dashangToggle()" class="dashang" title="打赏，支持一下">打赏</a></p>
              <div class="hide_box-play"></div>
              <div class="shang_box-play">
                <a class="shang_close-play" href="javascript:void(0)" onclick="dashangToggle()" title="关闭"><img src="/images/payimg/close.jpg" alt="取消" /></a>
                <div class="shang_tit-play">
                  <p>感谢您的支持，我会继续努力的!</p>
                </div>
                <div class="shang_payimg">
                    <img src="/images/payimg/alipayimg.jpg" alt="扫码支持" title="扫一扫" />
                </div>
              <div class="shang_payimg">
                    <img src="/images/payimg/weipayimg.jpg" alt="扫码支持" title="扫一扫" />
                </div>
                <div class="pay_explain">扫码打赏，你说多少就多少</div>
                <div class="shang_payselect">
                  <div class="pay_item checked" data-id="alipay">
                    <span class="pay_logo"><img src="/images/payimg/alipay.jpg" alt="支付宝" /></span>
                  </div>
                  <div class="pay_item" data-id="weipay">
                    <span class="pay_logo"><img src="/images/payimg/wechat.jpg" alt="微信" /></span>
                  </div>
                </div>
                <div class="shang_info-play">
                  <p>打开<span id="shang_pay_txt">支付宝</span>扫一扫，即可进行扫码打赏哦</p>
                </div>
              </div>
            </div>
            <script type="text/javascript">
            function dashangToggle(){
              $(".hide_box-play").fadeToggle();
              $(".shang_box-play").fadeToggle();
            }
            </script>

            <div style="text-align:center;margin:50px 0; font:normal 14px/24px 'MicroSoft YaHei';"></div>

            <style type="text/css">
              .content-play{width:80%;margin-top: 20px;margin-bottom: 10px;height:40px;}
              .hide_box-play{z-index:999;filter:alpha(opacity=50);background:#666;opacity: 0.5;-moz-opacity: 0.5;left:0;top:0;height:99%;width:100%;position:fixed;display:none;}
              .shang_box-play{width:540px;height:540px;padding:10px;background-color:#fff;border-radius:10px;position:fixed;z-index:1000;left:50%;top:50%;margin-left:-280px;margin-top:-280px;border:1px dotted #dedede;display:none;}
              .shang_box-play img{border:none;border-width:0;}
              .dashang{display:block;width:100px;margin:5px auto;height:25px;line-height:25px;padding:10px;background-color:#E74851;color:#fff;text-align:center;text-decoration:none;border-radius:10px;font-weight:bold;font-size:16px;transition: all 0.3s;}
              .dashang:hover{opacity:0.8;padding:15px;font-size:18px;}
              .shang_close-play{float:right;display:inline-block;
                margin-right: 10px;margin-top: 20px;
              }
              .shang_logo{display:block;text-align:center;margin:20px auto;}
              .shang_tit-play{width: 100%;height: 75px;text-align: center;line-height: 66px;color: #a3a3a3;font-size: 16px;background: url('/images/payimg/cy-reward-title-bg.jpg');font-family: 'Microsoft YaHei';margin-top: 7px;margin-right:2px;}
              .shang_tit-play p{color:#a3a3a3;text-align:center;font-size:16px;}
              .shang_payimg{width:140px;padding:10px;padding-left: 80px; /*border:6px solid #EA5F00;**/margin:0 auto;border-radius:3px;height:140px;display:inline-block;}
              .shang_payimg img{display:inline-block;margin-right:10px;float:left;text-align:center;width:140px;height:140px; }
              .pay_explain{text-align:center;margin:10px auto;font-size:12px;color:#545454;}
              .shang_payselect{text-align:center;margin:0 auto;margin-top:40px;cursor:pointer;height:60px;width:500px;margin-left:110px;}
              .shang_payselect .pay_item{display:inline-block;margin-right:140px;float:left;}
              .shang_info-play{clear:both;}
              .shang_info-play p,.shang_info-play a{color:#C3C3C3;text-align:center;font-size:12px;text-decoration:none;line-height:2em;}
            </style>

       <ul class="pager">
        
        <li class="previous">
            <a href="/2017/08/19/blockchain-dev/" data-toggle="tooltip" data-placement="top" title="Go实现公链底层开发（三）">上一篇：  <span>Go实现公链底层开发（三）</span>
            </a>
        </li>
        
        
        <li class="next">
            <a href="/2017/08/25/blockchain-dev/" data-toggle="tooltip" data-placement="top" title="Go实现公链底层开发（五）">下一篇：  <span>Go实现公链底层开发（五）</span>
            </a>
        </li>
        
    </ul>
</section>

 <section class="footer">
  <footer>
    <div class="footer_div">
      <nav class="cover-navigation navigation--social">
        <ul class="navigation">

          
          <!-- Weibo -->
          <li class="navigation__item_social">
            <a href="http://weibo.com/zhaocongliang" title="@zhaocongliang 的微博" target="_blank">
              <i class='social fa fa-weibo fa-2x'></i>
              <span class="label">Weibo</span>
            </a>
          </li>
           
          <!-- Github -->
          <li class="navigation__item_social">
            <a href="https://github.com/zhaocongliang" title="@zhaocongliang 的 Github" target="_blank">
              <i class='social fa fa-github fa-2x'></i>
              <span class="label">Github</span>
            </a>
          </li>
            

          <!-- RSS -->
          <li class="navigation__item_social">
            <a href="/feed.xml" rel="author" title="RSS" target="_blank">
              <i class='social fa fa-rss fa-2x'></i>
              <span class="label">RSS</span>
            </a>
          </li>

          
          <!-- Email -->
          <li class="navigation__item_social">
            <a href="mailto:zhaocongliang7@163.com" title="Contact me">
              <i class='social fa fa-envelope fa-2x'></i>
              <span class="label">Email</span>
            </a>
          </li>
          

        </ul>
      </nav>

    </div>

    <table width="100%" border="0" cellspacing="0" cellpadding="0">
      <thead>
        <tr id="bar_head">
          <th colspan="11">友情链接</th>
        </tr>
      </thead>

      <tr align="center" valign="middle">

          <td><a href="https://www.ethereum.org">以太坊官网</a></td>

          <td><a href="https://solidity.readthedocs.io/en/develop/">Solidity</a></td>

          <td><a href="http://truffleframework.com/">Truffle FrameWork</a></td>

          <td><a href="http://embark.readthedocs.io">Embark FrameWork</a></td>

          <td><a href="https://www.hyperledger.org/">hyperledger</a></td>

      </tr>
      <tr align="center" valign="middle">

          <td><a href="https://www.ibm.com/developerworks/community/groups/service/html/communityview?communityUuid=3302cc3b-074e-44da-90b1-5055f1dc0d9c&amp;lang=zh">IBM开源技术微讲堂</a></td>

          <td><a href="https://www.bitcoin.com/">Bitcoin.com</a></td>

          <td><a href="https://github.com/bitshares/bitshares1-core">bitshares1-core</a></td>

          <td><a href="https://ipfs.io">ipfs官网</a></td>

          <td><a href="http://ipfser.org">ipfs中文网</a></td>



      </tr>
    </table>

    <div class="footer_div">
      <p class="copyright text-muted">
        <!-- Copyright &copy; 2018 赵从亮区块链博客 京ICP备15065741号.  -->
      </p>
      <div align="right">
        <link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
        <!-- 访问统计
        <span id="busuanzi_container_site_pv">
            本站总访问量
            <span id="busuanzi_value_site_pv"></span>次
        </span>-->

      </div>
      <div>
  </footer>
</section>

    </div>
  </div>

  <script type="text/javascript" src="//code.jquery.com/jquery-1.11.3.min.js"></script>
<script type="text/javascript" src="/js/main.js"></script>

<script type="text/javascript" src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>




  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>


</body>

</html>