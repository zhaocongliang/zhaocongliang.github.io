<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>Go实现公链底层开发（六）</title>
  <meta name="description" content="在这个系列文章的一开始，我们就提到了，区块链是一个分布式数据库。不过在之前的文章中，我们选择性地跳过了“分布式”这个部分，而是将注意力都放到了“数据库”部分。到目前为止，我们几乎已经实现了一个区块链数据库的所有元素。今天，我们将会分析之前跳过的一些机制。而在下一篇文章中，我们将会开始讨论区块链的分布式特性。挖矿奖励，实际上就是一笔 coinbase 交易。当一个挖矿节点开始挖出一个新块时，它会将交易从队列中取出，并在前面附加一笔 coinbase 交易。coinbase 交易只有一个输出，里面包含了矿工的公钥哈希。">
  <meta name="author" content="赵从亮">

  <meta name="keywords" content="公链底层"
  />

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Go实现公链底层开发（六）">
  <meta name="twitter:description" content="在这个系列文章的一开始，我们就提到了，区块链是一个分布式数据库。不过在之前的文章中，我们选择性地跳过了“分布式”这个部分，而是将注意力都放到了“数据库”部分。到目前为止，我们几乎已经实现了一个区块链数据库的所有元素。今天，我们将会分析之前跳过的一些机制。而在下一篇文章中，我们将会开始讨论区块链的分布式特性。挖矿奖励，实际上就是一笔 coinbase 交易。当一个挖矿节点开始挖出一个新块时，它会将交易从队列中取出，并在前面附加一笔 coinbase 交易。coinbase 交易只有一个输出，里面包含了矿工的公钥哈希。">

  <meta property="og:type" content="article">
  <meta property="og:title" content="Go实现公链底层开发（六）">
  <meta property="og:description" content="在这个系列文章的一开始，我们就提到了，区块链是一个分布式数据库。不过在之前的文章中，我们选择性地跳过了“分布式”这个部分，而是将注意力都放到了“数据库”部分。到目前为止，我们几乎已经实现了一个区块链数据库的所有元素。今天，我们将会分析之前跳过的一些机制。而在下一篇文章中，我们将会开始讨论区块链的分布式特性。挖矿奖励，实际上就是一笔 coinbase 交易。当一个挖矿节点开始挖出一个新块时，它会将交易从队列中取出，并在前面附加一笔 coinbase 交易。coinbase 交易只有一个输出，里面包含了矿工的公钥哈希。">
  <meta property="og:site_name" content="公链底层e"
  />


  <link rel="icon" type="image/png" href="/images/favicon.png" />
  <link href="/images/favicon.png" rel="shortcut icon" type="image/png">


  <link rel="stylesheet" href=" /css/main.css ">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="http://localhost:4000/2017/08/31/blockchain-dev/">
  <link rel="alternate" type="application/rss+xml" title="赵从亮区块链博客" href="http://localhost:4000 /feed.xml
    ">

  <meta name="google-site-verification" content="1-1ZlHoRvM0T2FqPbW2S-qLgYXN6rsn52kErlMPd_gw" />

  <!-- 站点统计 -->
  <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
  </script>
  <!-- <script>(function() {var _53code = document.createElement("script");_53code.src = "https://tb.53kf.com/code/code/10174862/1";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(_53code, s);})();</script> -->
  <!-- 百度统计 -->
  
  <script>
    var _hmt = _hmt || [];
    (function () {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?f3290601666dc2ca016a38c340c144f1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>
  

  <!-- google 统计 -->
  
  <script>
    (function (i, s, o, g, r, a, m) {
      i['GoogleAnalyticsObject'] = r;
      i[r] = i[r] || function () {
        (i[r].q = i[r].q || []).push(arguments)
      }, i[r].l = 1 * new Date();
      a = s.createElement(o),
        m = s.getElementsByTagName(o)[0];
      a.async = 1;
      a.src = g;
      m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
    ga('create', 'UA-104237177-1', 'auto');
    ga('send', 'pageview');
  </script>
  

  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>

</head>


<body>

  <span class="mobile btn-mobile-menu">        
      <div class="nav_container">
         <nav class="nav-menu-item" style = "float:right">
            <i class="nav-menu-item">
              <a href="/#blog" title="" class="blog-button">  博客主页
              </a>
            </i>
            
                <i class="nav-menu-item">

                  <a href="/archive" title="archive" class="btn-mobile-menu__icon">
                      所有文章
                  </a>
                </i>
            
                <i class="nav-menu-item">

                  <a href="/tags" title="tags" class="btn-mobile-menu__icon">
                      分类
                  </a>
                </i>
            
                <i class="nav-menu-item">

                  <a href="/about" title="about" class="btn-mobile-menu__icon">
                      关于我
                  </a>
                </i>
            
          </nav>
          
      </div>
    </span> <header class="panel-cover panel-cover--collapsed" style="background-image: url('/images/background-cover.jpg')">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
      <div class="panel-main__content">
        <!-- 头像效果-start -->
        <div class="ih-item circle effect right_to_left">
          <a href="/#blog" title="前往 赵从亮区块链博客 的主页" class="blog-button">
            <div class="img"><img src="/images/avatar.jpg" alt="img"></div>
            <div class="info">
              <div class="info-back">
                <h2 style="font-size: 14px">
                   微信:13661944205 
                </h2>´
                <p style="font-size: 6px">
                   赵从亮 
                </p>
              </div>
            </div>
          </a>
        </div>
        <!-- 头像效果-end -->
        <h1 class="panel-cover__title panel-title"><a href="/#blog" title="link to homepage for 赵从亮区块链博客" class="blog-button">赵从亮区块链博客</a></h1>
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">赵从亮，区块链底层开发者、架构师。</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" /> 


        <div class="navigation-wrapper">
          <div>
            <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">博客主页</a></li>
                
                <li class="navigation__item"><a href="/archive" title="archive">所有文章</a></li>
                
                <li class="navigation__item"><a href="/tags" title="tags">分类</a></li>
                
                <li class="navigation__item"><a href="/about" title="about">关于我</a></li>
                
              </ul>
            </nav>
          </div>
        </div>

        <div style="display:flex;justify-content:center;-webkit-justify-content:center">
          <div style="display:flex;flex-direction:column;align-items:center;-webkit-flex-direction:column;-webkit-align-items:center;margin-right:10px">
            <img src="/images/zhishixingqiu.png" style="width:120px;height:120px;margin-top:30px;margin-bottom:10px" />
            <span class="panel-cover__subtitle panel-subtitle" style="font-size: 12px">请联系微信</span>
          </div>
          <div style="display:flex;flex-direction:column;align-items:center;-webkit-flex-direction:column;-webkit-align-items:center;margin-left:10px">
            <img src="/images/lianhu.jpg" style="width:120px;height:120px;margin-top:30px;margin-bottom:10px" />
            <span class="panel-cover__subtitle panel-subtitle" style="font-size: 12px">区块链公众号</span>
          </div>
        </div>

      </div>
    </div>
  </div>

  
  <div class="panel-cover--overlay cover-clear"></div>
  

  </div>
</header>


  <div class="content-wrapper">
    <div class="content-wrapper__inner">
      <article class="post-container post-container--single" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <h1 class="post-title">Go实现公链底层开发（六）</h1>
    <div class="post-meta">
      <img src="/images/calendar.png" width="20px"/>
      <time datetime="2017-08-31 00:00:00 +0800" itemprop="datePublished" class="post-meta__date date">2017-08-31</time>

      <!-- <span id="busuanzi_container_page_pv"> | 阅读：<span id="busuanzi_value_page_pv"></span>次</span> -->
    </p>
    </div>
  </header>

  <section class="post">
    <h2 id="交易2">交易（2）</h2>
<h2 id="引言">引言</h2>

<p>在这个系列文章的一开始，我们就提到了，区块链是一个分布式数据库。不过在之前的文章中，我们选择性地跳过了“分布式”这个部分，而是将注意力都放到了“数据库”部分。到目前为止，我们几乎已经实现了一个区块链数据库的所有元素。今天，我们将会分析之前跳过的一些机制。而在下一篇文章中，我们将会开始讨论区块链的分布式特性。</p>

<p>之前的系列文章：</p>

<ol>
  <li>基本原型</li>
  <li>工作量证明</li>
  <li>持久化和命令行接口</li>
  <li>交易（1）</li>
  <li>地址</li>
</ol>

<blockquote>
  <p>本文的代码实现变化很大，请点击 <a href="https://github.com/Jeiwan/blockchain_go/compare/part_5...part_6#files_bucket">这里</a> 查看所有的代码更改。</p>
</blockquote>

<h2 id="奖励">奖励</h2>

<p>在上一篇文章中，我们略过的一个小细节是挖矿奖励。现在，我们已经可以来完善这个细节了。</p>

<p>挖矿奖励，实际上就是一笔 coinbase 交易。当一个挖矿节点开始挖出一个新块时，它会将交易从队列中取出，并在前面附加一笔 coinbase 交易。coinbase 交易只有一个输出，里面包含了矿工的公钥哈希。</p>

<p>实现奖励，非常简单，更新 <code class="highlighter-rouge">send</code> 即可：</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">cli</span><span class="x"> </span><span class="o">*</span><span class="n">CLI</span><span class="p">)</span><span class="x"> </span><span class="n">send</span><span class="p">(</span><span class="n">from</span><span class="p">,</span><span class="x"> </span><span class="n">to</span><span class="x"> </span><span class="kt">string</span><span class="p">,</span><span class="x"> </span><span class="n">amount</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="o">...</span><span class="x">
    </span><span class="n">bc</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">NewBlockchain</span><span class="p">()</span><span class="x">
    </span><span class="n">UTXOSet</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">UTXOSet</span><span class="p">{</span><span class="n">bc</span><span class="p">}</span><span class="x">
    </span><span class="k">defer</span><span class="x"> </span><span class="n">bc</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span><span class="x">

    </span><span class="n">tx</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">NewUTXOTransaction</span><span class="p">(</span><span class="n">from</span><span class="p">,</span><span class="x"> </span><span class="n">to</span><span class="p">,</span><span class="x"> </span><span class="n">amount</span><span class="p">,</span><span class="x"> </span><span class="o">&amp;</span><span class="n">UTXOSet</span><span class="p">)</span><span class="x">
    </span><span class="n">cbTx</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">NewCoinbaseTX</span><span class="p">(</span><span class="n">from</span><span class="p">,</span><span class="x"> </span><span class="s">""</span><span class="p">)</span><span class="x">
    </span><span class="n">txs</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="p">[]</span><span class="o">*</span><span class="n">Transaction</span><span class="p">{</span><span class="n">cbTx</span><span class="p">,</span><span class="x"> </span><span class="n">tx</span><span class="p">}</span><span class="x">

    </span><span class="n">newBlock</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">bc</span><span class="o">.</span><span class="n">MineBlock</span><span class="p">(</span><span class="n">txs</span><span class="p">)</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Success!"</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p>在我们的实现中，创建交易的人同时挖出了新块，所以会得到一笔奖励。</p>

<h2 id="utxo-集">UTXO 集</h2>

<p>在 Part 3: 持久化和命令行接口 中，我们研究了 Bitcoin Core 是如何在一个数据库中存储块的，并且了解到区块被存储在 <code class="highlighter-rouge">blocks</code> 数据库，交易输出被存储在 <code class="highlighter-rouge">chainstate</code> 数据库。会回顾一下 <code class="highlighter-rouge">chainstate</code> 的机构：</p>

<ol>
  <li><code class="highlighter-rouge">c</code> + 32 字节的交易哈希 -&gt; 该笔交易的未花费交易输出记录</li>
  <li><code class="highlighter-rouge">B</code> + 32 字节的块哈希 -&gt; 未花费交易输出的块哈希</li>
</ol>

<p>在之前那篇文章中，虽然我们已经实现了交易，但是并没有使用 <code class="highlighter-rouge">chainstate</code> 来存储交易的输出。所以，接下来我们继续完成这部分。</p>

<p><code class="highlighter-rouge">chainstate</code> 不存储交易。它所存储的是 UTXO 集，也就是未花费交易输出的集合。除此以外，它还存储了“数据库表示的未花费交易输出的块哈希”，不过我们会暂时略过块哈希这一点，因为我们还没有用到块高度（但是我们会在接下来的文章中继续改进）。</p>

<p>那么，我们为什么需要 UTXO 集呢？</p>

<p>来思考一下我们早先实现的 <code class="highlighter-rouge">Blockchain.FindUnspentTransactions</code> 方法：</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">bc</span><span class="x"> </span><span class="o">*</span><span class="n">Blockchain</span><span class="p">)</span><span class="x"> </span><span class="n">FindUnspentTransactions</span><span class="p">(</span><span class="n">pubKeyHash</span><span class="x"> </span><span class="p">[]</span><span class="kt">byte</span><span class="p">)</span><span class="x"> </span><span class="p">[]</span><span class="n">Transaction</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="o">...</span><span class="x">
    </span><span class="n">bci</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">bc</span><span class="o">.</span><span class="n">Iterator</span><span class="p">()</span><span class="x">

    </span><span class="k">for</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">block</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">bci</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span><span class="x">

        </span><span class="k">for</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">tx</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">block</span><span class="o">.</span><span class="n">Transactions</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="o">...</span><span class="x">
        </span><span class="p">}</span><span class="x">

        </span><span class="k">if</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">PrevBlockHash</span><span class="p">)</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="m">0</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="k">break</span><span class="x">
        </span><span class="p">}</span><span class="x">
    </span><span class="p">}</span><span class="x">
    </span><span class="o">...</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p>这个函数找到有未花费输出的交易。由于交易被保存在区块中，所以它会对区块链里面的每一个区块进行迭代，检查里面的每一笔交易。截止 2017 年 9 月 18 日，在比特币中已经有 485，860 个块，整个数据库所需磁盘空间超过 140 Gb。这意味着一个人如果想要验证交易，必须要运行一个全节点。此外，验证交易将会需要在许多块上进行迭代。</p>

<p>整个问题的解决方案是有一个仅有未花费输出的索引，这就是 UTXO 集要做的事情：这是一个从所有区块链交易中构建（对区块进行迭代，但是只须做一次）而来的缓存，然后用它来计算余额和验证新的交易。截止 2017 年 9 月，UTXO 集大概有 2.7 Gb。</p>

<p>好了，让我们来想一下实现 UTXO 集的话需要作出哪些改变。目前，找到交易用到了以下一些方法：</p>

<ol>
  <li>
    <p><code class="highlighter-rouge">Blockchain.FindUnspentTransactions</code> - 找到有未花费输出交易的主要函数。也是在这个函数里面会对所有区块进行迭代。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">Blockchain.FindSpendableOutputs</code> - 这个函数用于当一个新的交易创建的时候。如果找到有所需数量的输出。使用 <code class="highlighter-rouge">Blockchain.FindUnspentTransactions</code>.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">Blockchain.FindUTXO</code> - 找到一个公钥哈希的未花费输出，然后用来获取余额。使用 <code class="highlighter-rouge">Blockchain.FindUnspentTransactions</code>.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">Blockchain.FindTransation</code> - 根据 ID 在区块链中找到一笔交易。它会在所有块上进行迭代直到找到它。</p>
  </li>
</ol>

<p>可以看到，所有方法都对数据库中的所有块进行迭代。但是目前我们还没有改进所有方法，因为 UTXO 集没法存储所有交易，只会存储那些有未花费输出的交易。因此，它无法用于 <code class="highlighter-rouge">Blockchain.FindTransaction</code>。</p>

<p>所以，我们想要以下方法：</p>

<ol>
  <li>
    <p><code class="highlighter-rouge">Blockchain.FindUTXO</code> - 通过对区块进行迭代找到所有未花费输出。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">UTXOSet.Reindex</code> - 使用 <code class="highlighter-rouge">UTXO</code> 找到未花费输出，然后在数据库中进行存储。这里就是缓存的地方。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">UTXOSet.FindSpendableOutputs</code> - 类似 <code class="highlighter-rouge">Blockchain.FindSpendableOutputs</code>，但是使用 UTXO 集。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">UTXOSet.FindUTXO</code> - 类似 <code class="highlighter-rouge">Blockchain.FindUTXO</code>，但是使用 UTXO 集。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">Blockchain.FindTransaction</code> 跟之前一样。</p>
  </li>
</ol>

<p>因此，从现在开始，两个最常用的函数将会使用 cache！来开始写代码吧。</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">UTXOSet</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">Blockchain</span><span class="x"> </span><span class="o">*</span><span class="n">Blockchain</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p>我们将会使用一个单一数据库，但是我们会将 UTXO 集从存储在不同的 bucket 中。因此，<code class="highlighter-rouge">UTXOSet</code> 跟 <code class="highlighter-rouge">Blockchain</code> 一起。</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">u</span><span class="x"> </span><span class="n">UTXOSet</span><span class="p">)</span><span class="x"> </span><span class="n">Reindex</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">db</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">u</span><span class="o">.</span><span class="n">Blockchain</span><span class="o">.</span><span class="n">db</span><span class="x">
    </span><span class="n">bucketName</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="n">utxoBucket</span><span class="p">)</span><span class="x">

    </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">db</span><span class="o">.</span><span class="n">Update</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">tx</span><span class="x"> </span><span class="o">*</span><span class="n">bolt</span><span class="o">.</span><span class="n">Tx</span><span class="p">)</span><span class="x"> </span><span class="kt">error</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">tx</span><span class="o">.</span><span class="n">DeleteBucket</span><span class="p">(</span><span class="n">bucketName</span><span class="p">)</span><span class="x">
        </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">tx</span><span class="o">.</span><span class="n">CreateBucket</span><span class="p">(</span><span class="n">bucketName</span><span class="p">)</span><span class="x">
    </span><span class="p">})</span><span class="x">

    </span><span class="n">UTXO</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">u</span><span class="o">.</span><span class="n">Blockchain</span><span class="o">.</span><span class="n">FindUTXO</span><span class="p">()</span><span class="x">

    </span><span class="n">err</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">db</span><span class="o">.</span><span class="n">Update</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">tx</span><span class="x"> </span><span class="o">*</span><span class="n">bolt</span><span class="o">.</span><span class="n">Tx</span><span class="p">)</span><span class="x"> </span><span class="kt">error</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">b</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">tx</span><span class="o">.</span><span class="n">Bucket</span><span class="p">(</span><span class="n">bucketName</span><span class="p">)</span><span class="x">

        </span><span class="k">for</span><span class="x"> </span><span class="n">txID</span><span class="p">,</span><span class="x"> </span><span class="n">outs</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">UTXO</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="n">key</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">hex</span><span class="o">.</span><span class="n">DecodeString</span><span class="p">(</span><span class="n">txID</span><span class="p">)</span><span class="x">
            </span><span class="n">err</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">b</span><span class="o">.</span><span class="n">Put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="x"> </span><span class="n">outs</span><span class="o">.</span><span class="n">Serialize</span><span class="p">())</span><span class="x">
        </span><span class="p">}</span><span class="x">
    </span><span class="p">})</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p>这个方法初始化了 UTXO 集。首先，如果 bucket 存在就先移除，然后从区块链中获取所有的未花费输出，最终将输出保存到 bucket 中。</p>

<p><code class="highlighter-rouge">Blockchain.FindUTXO</code> 几乎跟 <code class="highlighter-rouge">Blockchain.FindUnspentTransactions</code> 一模一样，但是现在它返回了一个 <code class="highlighter-rouge">TransactionID -&gt; TransactionOutputs</code> 的 map。</p>

<p>现在，UTXO 集可以用于发送币：</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">u</span><span class="x"> </span><span class="n">UTXOSet</span><span class="p">)</span><span class="x"> </span><span class="n">FindSpendableOutputs</span><span class="p">(</span><span class="n">pubkeyHash</span><span class="x"> </span><span class="p">[]</span><span class="kt">byte</span><span class="p">,</span><span class="x"> </span><span class="n">amount</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">unspentOutputs</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">int</span><span class="p">)</span><span class="x">
    </span><span class="n">accumulated</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="x">
    </span><span class="n">db</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">u</span><span class="o">.</span><span class="n">Blockchain</span><span class="o">.</span><span class="n">db</span><span class="x">

    </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">db</span><span class="o">.</span><span class="n">View</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">tx</span><span class="x"> </span><span class="o">*</span><span class="n">bolt</span><span class="o">.</span><span class="n">Tx</span><span class="p">)</span><span class="x"> </span><span class="kt">error</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">b</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">tx</span><span class="o">.</span><span class="n">Bucket</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="n">utxoBucket</span><span class="p">))</span><span class="x">
        </span><span class="n">c</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">b</span><span class="o">.</span><span class="n">Cursor</span><span class="p">()</span><span class="x">

        </span><span class="k">for</span><span class="x"> </span><span class="n">k</span><span class="p">,</span><span class="x"> </span><span class="n">v</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">c</span><span class="o">.</span><span class="n">First</span><span class="p">();</span><span class="x"> </span><span class="n">k</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="p">;</span><span class="x"> </span><span class="n">k</span><span class="p">,</span><span class="x"> </span><span class="n">v</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">c</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="n">txID</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">hex</span><span class="o">.</span><span class="n">EncodeToString</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="x">
            </span><span class="n">outs</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">DeserializeOutputs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="x">

            </span><span class="k">for</span><span class="x"> </span><span class="n">outIdx</span><span class="p">,</span><span class="x"> </span><span class="n">out</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">outs</span><span class="o">.</span><span class="n">Outputs</span><span class="x"> </span><span class="p">{</span><span class="x">
                </span><span class="k">if</span><span class="x"> </span><span class="n">out</span><span class="o">.</span><span class="n">IsLockedWithKey</span><span class="p">(</span><span class="n">pubkeyHash</span><span class="p">)</span><span class="x"> </span><span class="o">&amp;&amp;</span><span class="x"> </span><span class="n">accumulated</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="n">amount</span><span class="x"> </span><span class="p">{</span><span class="x">
                    </span><span class="n">accumulated</span><span class="x"> </span><span class="o">+=</span><span class="x"> </span><span class="n">out</span><span class="o">.</span><span class="n">Value</span><span class="x">
                    </span><span class="n">unspentOutputs</span><span class="p">[</span><span class="n">txID</span><span class="p">]</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">append</span><span class="p">(</span><span class="n">unspentOutputs</span><span class="p">[</span><span class="n">txID</span><span class="p">],</span><span class="x"> </span><span class="n">outIdx</span><span class="p">)</span><span class="x">
                </span><span class="p">}</span><span class="x">
            </span><span class="p">}</span><span class="x">
        </span><span class="p">}</span><span class="x">
    </span><span class="p">})</span><span class="x">

    </span><span class="k">return</span><span class="x"> </span><span class="n">accumulated</span><span class="p">,</span><span class="x"> </span><span class="n">unspentOutputs</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p>或者检查余额：</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">u</span><span class="x"> </span><span class="n">UTXOSet</span><span class="p">)</span><span class="x"> </span><span class="n">FindUTXO</span><span class="p">(</span><span class="n">pubKeyHash</span><span class="x"> </span><span class="p">[]</span><span class="kt">byte</span><span class="p">)</span><span class="x"> </span><span class="p">[]</span><span class="n">TXOutput</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">var</span><span class="x"> </span><span class="n">UTXOs</span><span class="x"> </span><span class="p">[]</span><span class="n">TXOutput</span><span class="x">
    </span><span class="n">db</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">u</span><span class="o">.</span><span class="n">Blockchain</span><span class="o">.</span><span class="n">db</span><span class="x">

    </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">db</span><span class="o">.</span><span class="n">View</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">tx</span><span class="x"> </span><span class="o">*</span><span class="n">bolt</span><span class="o">.</span><span class="n">Tx</span><span class="p">)</span><span class="x"> </span><span class="kt">error</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">b</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">tx</span><span class="o">.</span><span class="n">Bucket</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="n">utxoBucket</span><span class="p">))</span><span class="x">
        </span><span class="n">c</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">b</span><span class="o">.</span><span class="n">Cursor</span><span class="p">()</span><span class="x">

        </span><span class="k">for</span><span class="x"> </span><span class="n">k</span><span class="p">,</span><span class="x"> </span><span class="n">v</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">c</span><span class="o">.</span><span class="n">First</span><span class="p">();</span><span class="x"> </span><span class="n">k</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="p">;</span><span class="x"> </span><span class="n">k</span><span class="p">,</span><span class="x"> </span><span class="n">v</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">c</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="n">outs</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">DeserializeOutputs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="x">

            </span><span class="k">for</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">out</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">outs</span><span class="o">.</span><span class="n">Outputs</span><span class="x"> </span><span class="p">{</span><span class="x">
                </span><span class="k">if</span><span class="x"> </span><span class="n">out</span><span class="o">.</span><span class="n">IsLockedWithKey</span><span class="p">(</span><span class="n">pubKeyHash</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
                    </span><span class="n">UTXOs</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">append</span><span class="p">(</span><span class="n">UTXOs</span><span class="p">,</span><span class="x"> </span><span class="n">out</span><span class="p">)</span><span class="x">
                </span><span class="p">}</span><span class="x">
            </span><span class="p">}</span><span class="x">
        </span><span class="p">}</span><span class="x">

        </span><span class="k">return</span><span class="x"> </span><span class="no">nil</span><span class="x">
    </span><span class="p">})</span><span class="x">

    </span><span class="k">return</span><span class="x"> </span><span class="n">UTXOs</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p>这是 <code class="highlighter-rouge">Blockchain</code> 方法的简单修改后的版本。这个 <code class="highlighter-rouge">Blockchain</code> 方法已经不再需要了。</p>

<p>有了 UTXO 集，也就意味着我们的数据（交易）现在已经被分开存储：实际交易被存储在区块链中，未花费输出被存储在 UTXO 集中。这样一来，我们就需要一个良好的同步机制，因为我们想要 UTXO 集时刻处于最新状态，并且存储最新交易的输出。但是我们不想每生成一个新块，就重新生成索引，因为这正是我们要极力避免的频繁区块链扫描。因此，我们需要一个机制来更新 UTXO 集：</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">u</span><span class="x"> </span><span class="n">UTXOSet</span><span class="p">)</span><span class="x"> </span><span class="n">Update</span><span class="p">(</span><span class="n">block</span><span class="x"> </span><span class="o">*</span><span class="n">Block</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">db</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">u</span><span class="o">.</span><span class="n">Blockchain</span><span class="o">.</span><span class="n">db</span><span class="x">

    </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">db</span><span class="o">.</span><span class="n">Update</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">tx</span><span class="x"> </span><span class="o">*</span><span class="n">bolt</span><span class="o">.</span><span class="n">Tx</span><span class="p">)</span><span class="x"> </span><span class="kt">error</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">b</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">tx</span><span class="o">.</span><span class="n">Bucket</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="n">utxoBucket</span><span class="p">))</span><span class="x">

        </span><span class="k">for</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">tx</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">block</span><span class="o">.</span><span class="n">Transactions</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="k">if</span><span class="x"> </span><span class="n">tx</span><span class="o">.</span><span class="n">IsCoinbase</span><span class="p">()</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="no">false</span><span class="x"> </span><span class="p">{</span><span class="x">
                </span><span class="k">for</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">vin</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">tx</span><span class="o">.</span><span class="n">Vin</span><span class="x"> </span><span class="p">{</span><span class="x">
                    </span><span class="n">updatedOuts</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">TXOutputs</span><span class="p">{}</span><span class="x">
                    </span><span class="n">outsBytes</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">b</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="n">vin</span><span class="o">.</span><span class="n">Txid</span><span class="p">)</span><span class="x">
                    </span><span class="n">outs</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">DeserializeOutputs</span><span class="p">(</span><span class="n">outsBytes</span><span class="p">)</span><span class="x">

                    </span><span class="k">for</span><span class="x"> </span><span class="n">outIdx</span><span class="p">,</span><span class="x"> </span><span class="n">out</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">outs</span><span class="o">.</span><span class="n">Outputs</span><span class="x"> </span><span class="p">{</span><span class="x">
                        </span><span class="k">if</span><span class="x"> </span><span class="n">outIdx</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="n">vin</span><span class="o">.</span><span class="n">Vout</span><span class="x"> </span><span class="p">{</span><span class="x">
                            </span><span class="n">updatedOuts</span><span class="o">.</span><span class="n">Outputs</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">append</span><span class="p">(</span><span class="n">updatedOuts</span><span class="o">.</span><span class="n">Outputs</span><span class="p">,</span><span class="x"> </span><span class="n">out</span><span class="p">)</span><span class="x">
                        </span><span class="p">}</span><span class="x">
                    </span><span class="p">}</span><span class="x">

                    </span><span class="k">if</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">updatedOuts</span><span class="o">.</span><span class="n">Outputs</span><span class="p">)</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="m">0</span><span class="x"> </span><span class="p">{</span><span class="x">
                        </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">b</span><span class="o">.</span><span class="n">Delete</span><span class="p">(</span><span class="n">vin</span><span class="o">.</span><span class="n">Txid</span><span class="p">)</span><span class="x">
                    </span><span class="p">}</span><span class="x"> </span><span class="k">else</span><span class="x"> </span><span class="p">{</span><span class="x">
                        </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">b</span><span class="o">.</span><span class="n">Put</span><span class="p">(</span><span class="n">vin</span><span class="o">.</span><span class="n">Txid</span><span class="p">,</span><span class="x"> </span><span class="n">updatedOuts</span><span class="o">.</span><span class="n">Serialize</span><span class="p">())</span><span class="x">
                    </span><span class="p">}</span><span class="x">

                </span><span class="p">}</span><span class="x">
            </span><span class="p">}</span><span class="x">

            </span><span class="n">newOutputs</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">TXOutputs</span><span class="p">{}</span><span class="x">
            </span><span class="k">for</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">out</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">tx</span><span class="o">.</span><span class="n">Vout</span><span class="x"> </span><span class="p">{</span><span class="x">
                </span><span class="n">newOutputs</span><span class="o">.</span><span class="n">Outputs</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">append</span><span class="p">(</span><span class="n">newOutputs</span><span class="o">.</span><span class="n">Outputs</span><span class="p">,</span><span class="x"> </span><span class="n">out</span><span class="p">)</span><span class="x">
            </span><span class="p">}</span><span class="x">

            </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">b</span><span class="o">.</span><span class="n">Put</span><span class="p">(</span><span class="n">tx</span><span class="o">.</span><span class="n">ID</span><span class="p">,</span><span class="x"> </span><span class="n">newOutputs</span><span class="o">.</span><span class="n">Serialize</span><span class="p">())</span><span class="x">
        </span><span class="p">}</span><span class="x">
    </span><span class="p">})</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p>虽然这个方法看起来有点复杂，但是它所要做的事情非常直观。当挖出一个新块时，应该更新 UTXO 集。更新意味着移除已花费输出，并从新挖出来的交易中加入未花费输出。如果一笔交易的输出被移除，并且不再包含任何输出，那么这笔交易也应该被移除。相当简单！</p>

<p>现在让我们在必要的时候使用 UTXO 集：</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">cli</span><span class="x"> </span><span class="o">*</span><span class="n">CLI</span><span class="p">)</span><span class="x"> </span><span class="n">createBlockchain</span><span class="p">(</span><span class="n">address</span><span class="x"> </span><span class="kt">string</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="o">...</span><span class="x">
    </span><span class="n">bc</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">CreateBlockchain</span><span class="p">(</span><span class="n">address</span><span class="p">)</span><span class="x">
    </span><span class="k">defer</span><span class="x"> </span><span class="n">bc</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span><span class="x">

    </span><span class="n">UTXOSet</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">UTXOSet</span><span class="p">{</span><span class="n">bc</span><span class="p">}</span><span class="x">
    </span><span class="n">UTXOSet</span><span class="o">.</span><span class="n">Reindex</span><span class="p">()</span><span class="x">
    </span><span class="o">...</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p>当一个新的区块链被创建以后，就会立刻进行重建索引。目前，这是 <code class="highlighter-rouge">Reindex</code> 唯一使用的地方，即使这里看起来有点“杀鸡用牛刀”，因为一条链开始的时候，只有一个块，里面只有一笔交易，<code class="highlighter-rouge">Update</code> 已经被使用了。不过我们在未来可能需要重建索引的机制。</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">cli</span><span class="x"> </span><span class="o">*</span><span class="n">CLI</span><span class="p">)</span><span class="x"> </span><span class="n">send</span><span class="p">(</span><span class="n">from</span><span class="p">,</span><span class="x"> </span><span class="n">to</span><span class="x"> </span><span class="kt">string</span><span class="p">,</span><span class="x"> </span><span class="n">amount</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="o">...</span><span class="x">
    </span><span class="n">newBlock</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">bc</span><span class="o">.</span><span class="n">MineBlock</span><span class="p">(</span><span class="n">txs</span><span class="p">)</span><span class="x">
    </span><span class="n">UTXOSet</span><span class="o">.</span><span class="n">Update</span><span class="p">(</span><span class="n">newBlock</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p>当挖出一个新块时，UTXO 集就会进行更新。</p>

<p>让我们来检查一下如否如期工作：</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="err">$</span><span class="x"> </span><span class="n">blockchain_go</span><span class="x"> </span><span class="n">createblockchain</span><span class="x"> </span><span class="o">-</span><span class="n">address</span><span class="x"> </span><span class="m">1</span><span class="n">JnMDSqVoHi4TEFXNw5wJ8skPsPf4LHkQ1</span><span class="x">
</span><span class="m">00000086</span><span class="n">a725e18ed7e9e06f1051651a4fc46a315a9d298e59e57aeacbe0bf73</span><span class="x">

</span><span class="n">Done</span><span class="o">!</span><span class="x">

</span><span class="err">$</span><span class="x"> </span><span class="n">blockchain_go</span><span class="x"> </span><span class="n">send</span><span class="x"> </span><span class="o">-</span><span class="n">from</span><span class="x"> </span><span class="m">1</span><span class="n">JnMDSqVoHi4TEFXNw5wJ8skPsPf4LHkQ1</span><span class="x"> </span><span class="o">-</span><span class="n">to</span><span class="x"> </span><span class="m">12</span><span class="n">DkLzLQ4B3gnQt62EPRJGZ38n3zF4Hzt5</span><span class="x"> </span><span class="o">-</span><span class="n">amount</span><span class="x"> </span><span class="m">6</span><span class="x">
</span><span class="m">0000001</span><span class="n">f75cb3a5033aeecbf6a8d378e15b25d026fb0a665c7721a5bb0faa21b</span><span class="x">

</span><span class="n">Success</span><span class="o">!</span><span class="x">

</span><span class="err">$</span><span class="x"> </span><span class="n">blockchain_go</span><span class="x"> </span><span class="n">send</span><span class="x"> </span><span class="o">-</span><span class="n">from</span><span class="x"> </span><span class="m">1</span><span class="n">JnMDSqVoHi4TEFXNw5wJ8skPsPf4LHkQ1</span><span class="x"> </span><span class="o">-</span><span class="n">to</span><span class="x"> </span><span class="m">12</span><span class="n">ncZhA5mFTTnTmHq1aTPYBri4jAK8TacL</span><span class="x"> </span><span class="o">-</span><span class="n">amount</span><span class="x"> </span><span class="m">4</span><span class="x">
</span><span class="m">000000</span><span class="n">cc51e665d53c78af5e65774a72fc7b864140a8224bf4e7709d8e0fa433</span><span class="x">

</span><span class="n">Success</span><span class="o">!</span><span class="x">

</span><span class="err">$</span><span class="x"> </span><span class="n">blockchain_go</span><span class="x"> </span><span class="n">getbalance</span><span class="x"> </span><span class="o">-</span><span class="n">address</span><span class="x"> </span><span class="m">1</span><span class="n">JnMDSqVoHi4TEFXNw5wJ8skPsPf4LHkQ1</span><span class="x">
</span><span class="n">Balance</span><span class="x"> </span><span class="n">of</span><span class="x"> </span><span class="err">'</span><span class="m">1</span><span class="n">F4MbuqjcuJGymjcuYQMUVYB37AWKkSLif</span><span class="err">'</span><span class="o">:</span><span class="x"> </span><span class="m">20</span><span class="x">

</span><span class="err">$</span><span class="x"> </span><span class="n">blockchain_go</span><span class="x"> </span><span class="n">getbalance</span><span class="x"> </span><span class="o">-</span><span class="n">address</span><span class="x"> </span><span class="m">12</span><span class="n">DkLzLQ4B3gnQt62EPRJGZ38n3zF4Hzt5</span><span class="x">
</span><span class="n">Balance</span><span class="x"> </span><span class="n">of</span><span class="x"> </span><span class="err">'</span><span class="m">1</span><span class="n">XWu6nitBWe6J6v6MXmd5rhdP7dZsExbx</span><span class="err">'</span><span class="o">:</span><span class="x"> </span><span class="m">6</span><span class="x">

</span><span class="err">$</span><span class="x"> </span><span class="n">blockchain_go</span><span class="x"> </span><span class="n">getbalance</span><span class="x"> </span><span class="o">-</span><span class="n">address</span><span class="x"> </span><span class="m">12</span><span class="n">ncZhA5mFTTnTmHq1aTPYBri4jAK8TacL</span><span class="x">
</span><span class="n">Balance</span><span class="x"> </span><span class="n">of</span><span class="x"> </span><span class="err">'</span><span class="m">13</span><span class="n">UASQpCR8Nr41PojH8Bz4K6cmTCqweskL</span><span class="err">'</span><span class="o">:</span><span class="x"> </span><span class="m">4</span><span class="x">
</span></code></pre>
</div>

<p>很好！<code class="highlighter-rouge">1JnMDSqVoHi4TEFXNw5wJ8skPsPf4LHkQ1</code> 地址接收到了 3 笔奖励：</p>

<ol>
  <li>一次是挖出创世块</li>
  <li>一次是挖出块 0000001f75cb3a5033aeecbf6a8d378e15b25d026fb0a665c7721a5bb0faa21b</li>
  <li>一个是挖出块 000000cc51e665d53c78af5e65774a72fc7b864140a8224bf4e7709d8e0fa433</li>
</ol>

<h2 id="merkle-树">Merkle 树</h2>

<p>在这篇文章中，我还想要再讨论一个优化机制。</p>

<p>上如上面所提到的，完整的比特币数据库（也就是区块链）需要超过 140 Gb 的磁盘空间。因为比特币的去中心化特性，网络中的每个节点必须是独立，自给自足的，也就是每个节点必须存储一个区块链的完整副本。随着越来越多的人使用比特币，这条规则变得越来越难以遵守：因为不太可能每个人都去运行一个全节点。并且，由于节点是网络中的完全参与者，它们负有相关责任：节点必须验证交易和区块。另外，要想与其他节点交互和下载新块，也有一定的网络流量需求。</p>

<p>在中本聪的 <a href="https://bitcoin.org/bitcoin.pdf">比特币原始论文</a> 中，对这个问题也有一个解决方案：简易支付验证（Simplified Payment Verification, SPV）。SPV 是一个比特币轻节点，它不需要下载整个区块链，也<strong>不需要验证区块和交易</strong>。相反，它会在区块链查找交易（为了验证支付），并且需要连接到一个全节点来检索必要的数据。这个机制允许在仅运行一个全节点的情况下有多个轻钱包。</p>

<p>为了实现 SPV，需要有一个方式来检查是否一个区块包含了某笔交易，而无须下载整个区块。这就是 Merkle 树所要完成的事情。</p>

<p>比特币用 Merkle 树来获取交易哈希，哈希被保存在区块头中，并会用于工作量证明系统。到目前为止，我们只是将一个块里面的每笔交易哈希连接了起来，将在上面应用了 SHA-256 算法。虽然这是一个用于获取区块交易唯一表示的一个不错的途径，但是它没有利用到 Merkle 树。</p>

<p>来看一下 Merkle 树：</p>

<p><img src="http://upload-images.jianshu.io/upload_images/127313-9c708d3c3d6a19c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Merkle tree" /></p>

<p>每个块都会有一个 Merkle 树，它从叶子节点（树的底部）开始，一个叶子节点就是一个交易哈希（比特币使用双 SHA256 哈希）。叶子节点的数量必须是双数，但是并非每个块都包含了双数的交易。因为，如果一个块里面的交易数为单数，那么就将最后一个叶子节点（也就是 Merkle 树的最后一个交易，不是区块的最后一笔交易）复制一份凑成双数。</p>

<p>从下往上，两两成对，连接两个节点哈希，将组合哈希作为新的哈希。新的哈希就成为新的树节点。重复该过程，直到仅有一个节点，也就是树根。根哈希然后就会当做是整个块交易的唯一标示，将它保存到区块头，然后用于工作量证明。</p>

<p>Merkle 树的好处就是一个节点可以在不下载整个块的情况下，验证是否包含某笔交易。并且这些只需要一个交易哈希，一个 Merkle 树根哈希和一个 Merkle 路径。</p>

<p>最后，来写代码：</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">MerkleTree</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">RootNode</span><span class="x"> </span><span class="o">*</span><span class="n">MerkleNode</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">type</span><span class="x"> </span><span class="n">MerkleNode</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">Left</span><span class="x">  </span><span class="o">*</span><span class="n">MerkleNode</span><span class="x">
    </span><span class="n">Right</span><span class="x"> </span><span class="o">*</span><span class="n">MerkleNode</span><span class="x">
    </span><span class="n">Data</span><span class="x">  </span><span class="p">[]</span><span class="kt">byte</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p>先从结构体开始。每个 <code class="highlighter-rouge">MerkleNode</code> 包含数据和指向左右分支的指针。<code class="highlighter-rouge">MerkleTree</code> 实际上就是连接到下个节点的根节点，然后依次连接到更远的节点，等等。</p>

<p>让我们首先来创建一个新的节点：</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">NewMerkleNode</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="x"> </span><span class="n">right</span><span class="x"> </span><span class="o">*</span><span class="n">MerkleNode</span><span class="p">,</span><span class="x"> </span><span class="n">data</span><span class="x"> </span><span class="p">[]</span><span class="kt">byte</span><span class="p">)</span><span class="x"> </span><span class="o">*</span><span class="n">MerkleNode</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">mNode</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">MerkleNode</span><span class="p">{}</span><span class="x">

    </span><span class="k">if</span><span class="x"> </span><span class="n">left</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="o">&amp;&amp;</span><span class="x"> </span><span class="n">right</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">hash</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">sha256</span><span class="o">.</span><span class="n">Sum256</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="x">
        </span><span class="n">mNode</span><span class="o">.</span><span class="n">Data</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">hash</span><span class="p">[</span><span class="o">:</span><span class="p">]</span><span class="x">
    </span><span class="p">}</span><span class="x"> </span><span class="k">else</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">prevHashes</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">append</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">Data</span><span class="p">,</span><span class="x"> </span><span class="n">right</span><span class="o">.</span><span class="n">Data</span><span class="o">...</span><span class="p">)</span><span class="x">
        </span><span class="n">hash</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">sha256</span><span class="o">.</span><span class="n">Sum256</span><span class="p">(</span><span class="n">prevHashes</span><span class="p">)</span><span class="x">
        </span><span class="n">mNode</span><span class="o">.</span><span class="n">Data</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">hash</span><span class="p">[</span><span class="o">:</span><span class="p">]</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="n">mNode</span><span class="o">.</span><span class="n">Left</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">left</span><span class="x">
    </span><span class="n">mNode</span><span class="o">.</span><span class="n">Right</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">right</span><span class="x">

    </span><span class="k">return</span><span class="x"> </span><span class="o">&amp;</span><span class="n">mNode</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p>每个节点包含一些数据。当节点在叶子节点，数据从外界传入（在这里，也就是一个序列化后的交易）。当一个节点被关联到其他节点，它会将其他节点的数据取过来，连接后再哈希。</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">NewMerkleTree</span><span class="p">(</span><span class="n">data</span><span class="x"> </span><span class="p">[][]</span><span class="kt">byte</span><span class="p">)</span><span class="x"> </span><span class="o">*</span><span class="n">MerkleTree</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">var</span><span class="x"> </span><span class="n">nodes</span><span class="x"> </span><span class="p">[]</span><span class="n">MerkleNode</span><span class="x">

    </span><span class="k">if</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">%</span><span class="m">2</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="m">0</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">data</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">append</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="x"> </span><span class="n">data</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">])</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="k">for</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">datum</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">data</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">node</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">NewMerkleNode</span><span class="p">(</span><span class="no">nil</span><span class="p">,</span><span class="x"> </span><span class="no">nil</span><span class="p">,</span><span class="x"> </span><span class="n">datum</span><span class="p">)</span><span class="x">
        </span><span class="n">nodes</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">append</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="x"> </span><span class="o">*</span><span class="n">node</span><span class="p">)</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">/</span><span class="m">2</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">var</span><span class="x"> </span><span class="n">newLevel</span><span class="x"> </span><span class="p">[]</span><span class="n">MerkleNode</span><span class="x">

        </span><span class="k">for</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="p">;</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">);</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="o">+=</span><span class="x"> </span><span class="m">2</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="n">node</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">NewMerkleNode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nodes</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="x"> </span><span class="o">&amp;</span><span class="n">nodes</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="m">1</span><span class="p">],</span><span class="x"> </span><span class="no">nil</span><span class="p">)</span><span class="x">
            </span><span class="n">newLevel</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">append</span><span class="p">(</span><span class="n">newLevel</span><span class="p">,</span><span class="x"> </span><span class="o">*</span><span class="n">node</span><span class="p">)</span><span class="x">
        </span><span class="p">}</span><span class="x">

        </span><span class="n">nodes</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">newLevel</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="n">mTree</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">MerkleTree</span><span class="p">{</span><span class="o">&amp;</span><span class="n">nodes</span><span class="p">[</span><span class="m">0</span><span class="p">]}</span><span class="x">

    </span><span class="k">return</span><span class="x"> </span><span class="o">&amp;</span><span class="n">mTree</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p>当生成一棵新树时，要确保的第一件事就是叶子节点必须是双数。然后，<strong>数据</strong>（也就是一个序列化后交易的数组）被转换成树的叶子，从这些叶子再慢慢形成一棵树。</p>

<p><a href="https://github.com/btcsuite/btcd/blob/50de9da05b50eb15658bb350f6ea24368a111ab7/blockchain/merkle.go#L71-L155">btcsuite/btcd</a> 是用数组实现的 merkle 树，因为这么做可以减少一半的内存使用。</p>

<p>现在，让我们来修改 <code class="highlighter-rouge">Block.HashTransactions</code>，它用于在工作量证明系统中获取交易哈希：</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">b</span><span class="x"> </span><span class="o">*</span><span class="n">Block</span><span class="p">)</span><span class="x"> </span><span class="n">HashTransactions</span><span class="p">()</span><span class="x"> </span><span class="p">[]</span><span class="kt">byte</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">var</span><span class="x"> </span><span class="n">transactions</span><span class="x"> </span><span class="p">[][]</span><span class="kt">byte</span><span class="x">

    </span><span class="k">for</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">tx</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">b</span><span class="o">.</span><span class="n">Transactions</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">transactions</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">append</span><span class="p">(</span><span class="n">transactions</span><span class="p">,</span><span class="x"> </span><span class="n">tx</span><span class="o">.</span><span class="n">Serialize</span><span class="p">())</span><span class="x">
    </span><span class="p">}</span><span class="x">
    </span><span class="n">mTree</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">NewMerkleTree</span><span class="p">(</span><span class="n">transactions</span><span class="p">)</span><span class="x">

    </span><span class="k">return</span><span class="x"> </span><span class="n">mTree</span><span class="o">.</span><span class="n">RootNode</span><span class="o">.</span><span class="n">Data</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p>首先，交易被序列化（使用 <code class="highlighter-rouge">encoding/gob</code>），然后使用序列后的交易构建一个 Mekle 树。树根将会作为块交易的唯一标识符。</p>

<h2 id="p2pkh">P2PKH</h2>

<p>还有一件事情，我想要再谈一谈。</p>

<p>大家应该还记得，在比特币中有一个 <em>脚本（Script）</em>编程语言，它用于锁定交易输出；交易输入提供了解锁输出的数据。这个语言非常简单，用这个语言写的代码其实就是一系列数据和操作符而已。比如如下示例：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>5 2 OP_ADD 7 OP_EQUAL
</code></pre>
</div>

<p>5, 2, 和 7 是数据，<code class="highlighter-rouge">OP_ADD</code> 和 <code class="highlighter-rouge">OP_EQUAL</code> 是操作符。<em>脚本</em>代码从左到右执行：将数据依次放入栈内，当遇到操作符时，就从栈内取出数据，并将操作符作用于数据，然后将结果作为栈顶元素。<em>脚本</em>的栈，实际上就是一个先进后出的内存存储：栈里的第一个元素最后一个取出，后面的每一个元素都会放到前一个元素之上。</p>

<p>让我们来对上面的脚本分部执行：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">步骤</th>
      <th style="text-align: left">栈</th>
      <th style="text-align: left">脚本</th>
      <th style="text-align: left">说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: left">空</td>
      <td style="text-align: left"><code class="highlighter-rouge">5 2 OP_ADD 7 OP_EQUAL</code></td>
      <td style="text-align: left">一开始栈为空</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: left"><code class="highlighter-rouge">5</code></td>
      <td style="text-align: left"><code class="highlighter-rouge">2 OP_ADD 7 OP_EQUAL</code></td>
      <td style="text-align: left">从脚本里面取出 <code class="highlighter-rouge">5</code> 放入栈上</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: left"><code class="highlighter-rouge">5 2</code></td>
      <td style="text-align: left"><code class="highlighter-rouge">OP_ADD 7 OP_EQUAL</code></td>
      <td style="text-align: left">从脚本里面取出 <code class="highlighter-rouge">2</code> 放入栈上</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: left"><code class="highlighter-rouge">7</code></td>
      <td style="text-align: left"><code class="highlighter-rouge">7 OP_EQUAL</code></td>
      <td style="text-align: left">遇到操作符 <code class="highlighter-rouge">OP_ADD</code>, 从栈里取出两个操作数 <code class="highlighter-rouge">5</code> 和 <code class="highlighter-rouge">2</code>，相加后将结果放回栈上</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: left"><code class="highlighter-rouge">7 7</code></td>
      <td style="text-align: left"><code class="highlighter-rouge">OP_EQUAL</code></td>
      <td style="text-align: left">从脚本里面取出 <code class="highlighter-rouge">7</code> 放到栈上</td>
    </tr>
    <tr>
      <td style="text-align: center">6</td>
      <td style="text-align: left"><code class="highlighter-rouge">true</code></td>
      <td style="text-align: left">空</td>
      <td style="text-align: left">遇到操作符 <code class="highlighter-rouge">OP_EQUAL</code>，从栈里取出两个操作数并比较，将比较的结果放回栈内，脚本执行完毕，为空</td>
    </tr>
  </tbody>
</table>

<p><code class="highlighter-rouge">OP_ADD</code> 从栈内取两个元素，将这两个元素进行相加，然后将结果重新放回栈内。<code class="highlighter-rouge">OP_EQUAL</code> 从栈内取两个元素，然后对这两个元素进行比较：如果它们相等，就在栈上放一个 <code class="highlighter-rouge">true</code>，否则放一个 <code class="highlighter-rouge">false</code>。脚本执行的结果就是栈顶元素：在我们的案例中，如果是 <code class="highlighter-rouge">true</code>，那么表明脚本执行成功。</p>

<p>现在来看一下在比特币中，是如何用脚本执行支付的：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;signature&gt; &lt;pubKey&gt; OP_DUP OP_HASH160 &lt;pubKeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG
</code></pre>
</div>

<p>这个脚本叫做 <em>Pay to Public Key Hash(P2PKH)</em>，这是比特币最常用的一个脚本。它所做的事情就是向一个公钥哈希支付，也就是说，用某一个公钥锁定一些币。这是<strong>比特币支付的核心</strong>：没有账户，没有资金转移；只有一个脚本检查提供的签名和公钥是否正确。</p>

<p>这个脚本实际存储为两个部分：</p>

<ol>
  <li>
    <p>第一个部分，<code class="highlighter-rouge">&lt;signature&gt; &lt;pubkey&gt;</code>，存储在输入的 <code class="highlighter-rouge">ScriptSig</code> 字段。</p>
  </li>
  <li>
    <p>第二部分，<code class="highlighter-rouge">OP_DUP OP_HASH160 &lt;pubkeyHash&gt; OP_EQUALVERYFY OP_CHECKSIG</code> 存储在输出的 <code class="highlighter-rouge">ScriptPubKey</code> 里面。</p>
  </li>
</ol>

<p>因此，输出定了解锁的逻辑，输入提供解锁输出的“钥匙”。然我们来执行一下这个脚本：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">步骤</th>
      <th style="text-align: left">栈</th>
      <th style="text-align: left">脚本</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: left">空</td>
      <td style="text-align: left"><code class="highlighter-rouge">&lt;signature&gt; &lt;pubKey&gt; OP_DUP OP_HASH160 &lt;pubKeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG</code></td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: left"><code class="highlighter-rouge">&lt;signature&gt;</code></td>
      <td style="text-align: left"><code class="highlighter-rouge">&lt;pubKey&gt; OP_DUP OP_HASH160 &lt;pubKeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG</code></td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: left"><code class="highlighter-rouge">&lt;signature&gt; &lt;pubkey&gt;</code></td>
      <td style="text-align: left"><code class="highlighter-rouge">OP_DUP OP_HASH160 &lt;pubKeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG</code></td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: left"><code class="highlighter-rouge">&lt;signature&gt; &lt;pubKey&gt; &lt;pubKey&gt;</code></td>
      <td style="text-align: left"><code class="highlighter-rouge">OP_HASH160 &lt;pubKeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG</code></td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: left"><code class="highlighter-rouge">&lt;signature&gt; &lt;pubKey&gt; &lt;pubKeyHash&gt;</code></td>
      <td style="text-align: left"><code class="highlighter-rouge">&lt;pubKeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG</code></td>
    </tr>
    <tr>
      <td style="text-align: center">6</td>
      <td style="text-align: left"><code class="highlighter-rouge">&lt;signature&gt; &lt;pubKey&gt; &lt;pubKeyHash&gt; &lt;pubKeyHash&gt;</code></td>
      <td style="text-align: left"><code class="highlighter-rouge">OP_EQUALVERIFY OP_CHECKSIG</code></td>
    </tr>
    <tr>
      <td style="text-align: center">7</td>
      <td style="text-align: left"><code class="highlighter-rouge">&lt;signature&gt; &lt;pubKey&gt;</code></td>
      <td style="text-align: left"><code class="highlighter-rouge">OP_CHECKSIG</code></td>
    </tr>
    <tr>
      <td style="text-align: center">8</td>
      <td style="text-align: left"><code class="highlighter-rouge">true</code> 或 <code class="highlighter-rouge">false</code></td>
      <td style="text-align: left">空</td>
    </tr>
  </tbody>
</table>

<p><code class="highlighter-rouge">OP_DUP</code> 对栈顶元素进行复制。<code class="highlighter-rouge">OP_HASH160</code> 取栈顶元素，然后用 <code class="highlighter-rouge">RIPEMD160</code> 对它进行哈希，再将结果送回到栈上。<code class="highlighter-rouge">OP_EQUALVERIFY</code> 将栈顶的两个元素进行比较，如果它们不相等，终止脚本。<code class="highlighter-rouge">OP_CHECKSIG</code> 通过对交易进行哈希，并使用 <code class="highlighter-rouge">&lt;signature&gt;</code> 和 <code class="highlighter-rouge">pubKey</code> 来验证一笔交易的签名。最后的操作符有点复杂：它生成了一个修剪后的交易副本，对它进行哈希（因为它是一个被签名后的交易哈希），然后使用提供的 <code class="highlighter-rouge">&lt;signature&gt;</code> 和 <code class="highlighter-rouge">pubKey</code> 检查签名是否正确。</p>

<p>有了一个这样的脚本语言，实际上也可以让比特币成为一个智能合约平台：除了将一个单一的公钥转移资金，这个语言还使得一些其他的支付方案成为可能。</p>

<h2 id="总结">总结</h2>

<p>这就是今天的全部内容了！我们已经实现了一个基于区块链的加密货币的几乎所有关键特性。我们已经有了区块链，地址，挖矿和交易。但是要想给这些所有的机制赋予生命，让比特币成为一个全球系统，还有一个不可或缺的环节：共识（consensus）。在下一篇文章中，我们将会开始实现区块链的“去中心化（decenteralized）”。敬请收听！</p>

<p>参考：</p>

<ol>
  <li><a href="https://github.com/Jeiwan/blockchain_go/tree/part_6">Full source codes</a></li>
  <li>[The UTXO Set](https://en.bitcoin.it/wiki/Bitcoin_Core_0.11_(ch_2)</li>
  <li><a href="https://en.bitcoin.it/wiki/Protocol_documentation#Merkle_Trees">Merkle Tree</a></li>
  <li><a href="https://en.bitcoin.it/wiki/Script">Script</a></li>
  <li><a href="https://github.com/sipa/bitcoin/commit/450cbb0944cd20a06ce806e6679a1f4c83c50db2">“Ultraprune” Bitcoin Core commit</a></li>
  <li><a href="https://statoshi.info/dashboard/db/unspent-transaction-output-set">UTXO set statistics</a></li>
  <li><a href="https://medium.com/@maraoz/smart-contracts-and-bitcoin-a5d61011d9b1">Smart contracts and Bitcoin</a></li>
  <li><a href="https://medium.com/@jonaldfyookball/why-every-bitcoin-user-should-understand-spv-security-520d1d45e0b9">Why every Bitcoin user should understand “SPV security”</a></li>
</ol>

<hr />
<p>文章转自：<a href="https://github.com/liuchengxu/blockchain-tutorial">https://github.com/liuchengxu/blockchain-tutorial</a>
原文翻译自：<a href="https://jeiwan.cc/posts/building-blockchain-in-go-part-6/">https://jeiwan.cc/posts/building-blockchain-in-go-part-1/</a></p>


  </section>
  <h3 style="color:red"><strong>版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请联系：13661944205</strong></h3>
  <h3 style="color:black"><strong>打赏以太币请博主喝咖啡：0xE49265DD6c9E2073b27ED3428887E29Ee37Ba318</strong></h3>
</article>

<section>

            <div class="content-play">
              <p><a href="javascript:void(0)" onclick="dashangToggle()" class="dashang" title="打赏，支持一下">打赏</a></p>
              <div class="hide_box-play"></div>
              <div class="shang_box-play">
                <a class="shang_close-play" href="javascript:void(0)" onclick="dashangToggle()" title="关闭"><img src="/images/payimg/close.jpg" alt="取消" /></a>
                <div class="shang_tit-play">
                  <p>感谢您的支持，我会继续努力的!</p>
                </div>
                <div class="shang_payimg">
                    <img src="/images/payimg/alipayimg.jpg" alt="扫码支持" title="扫一扫" />
                </div>
              <div class="shang_payimg">
                    <img src="/images/payimg/weipayimg.jpg" alt="扫码支持" title="扫一扫" />
                </div>
                <div class="pay_explain">扫码打赏，你说多少就多少</div>
                <div class="shang_payselect">
                  <div class="pay_item checked" data-id="alipay">
                    <span class="pay_logo"><img src="/images/payimg/alipay.jpg" alt="支付宝" /></span>
                  </div>
                  <div class="pay_item" data-id="weipay">
                    <span class="pay_logo"><img src="/images/payimg/wechat.jpg" alt="微信" /></span>
                  </div>
                </div>
                <div class="shang_info-play">
                  <p>打开<span id="shang_pay_txt">支付宝</span>扫一扫，即可进行扫码打赏哦</p>
                </div>
              </div>
            </div>
            <script type="text/javascript">
            function dashangToggle(){
              $(".hide_box-play").fadeToggle();
              $(".shang_box-play").fadeToggle();
            }
            </script>

            <div style="text-align:center;margin:50px 0; font:normal 14px/24px 'MicroSoft YaHei';"></div>

            <style type="text/css">
              .content-play{width:80%;margin-top: 20px;margin-bottom: 10px;height:40px;}
              .hide_box-play{z-index:999;filter:alpha(opacity=50);background:#666;opacity: 0.5;-moz-opacity: 0.5;left:0;top:0;height:99%;width:100%;position:fixed;display:none;}
              .shang_box-play{width:540px;height:540px;padding:10px;background-color:#fff;border-radius:10px;position:fixed;z-index:1000;left:50%;top:50%;margin-left:-280px;margin-top:-280px;border:1px dotted #dedede;display:none;}
              .shang_box-play img{border:none;border-width:0;}
              .dashang{display:block;width:100px;margin:5px auto;height:25px;line-height:25px;padding:10px;background-color:#E74851;color:#fff;text-align:center;text-decoration:none;border-radius:10px;font-weight:bold;font-size:16px;transition: all 0.3s;}
              .dashang:hover{opacity:0.8;padding:15px;font-size:18px;}
              .shang_close-play{float:right;display:inline-block;
                margin-right: 10px;margin-top: 20px;
              }
              .shang_logo{display:block;text-align:center;margin:20px auto;}
              .shang_tit-play{width: 100%;height: 75px;text-align: center;line-height: 66px;color: #a3a3a3;font-size: 16px;background: url('/images/payimg/cy-reward-title-bg.jpg');font-family: 'Microsoft YaHei';margin-top: 7px;margin-right:2px;}
              .shang_tit-play p{color:#a3a3a3;text-align:center;font-size:16px;}
              .shang_payimg{width:140px;padding:10px;padding-left: 80px; /*border:6px solid #EA5F00;**/margin:0 auto;border-radius:3px;height:140px;display:inline-block;}
              .shang_payimg img{display:inline-block;margin-right:10px;float:left;text-align:center;width:140px;height:140px; }
              .pay_explain{text-align:center;margin:10px auto;font-size:12px;color:#545454;}
              .shang_payselect{text-align:center;margin:0 auto;margin-top:40px;cursor:pointer;height:60px;width:500px;margin-left:110px;}
              .shang_payselect .pay_item{display:inline-block;margin-right:140px;float:left;}
              .shang_info-play{clear:both;}
              .shang_info-play p,.shang_info-play a{color:#C3C3C3;text-align:center;font-size:12px;text-decoration:none;line-height:2em;}
            </style>

       <ul class="pager">
        
        <li class="previous">
            <a href="/2017/08/25/blockchain-dev/" data-toggle="tooltip" data-placement="top" title="Go实现公链底层开发（五）">上一篇：  <span>Go实现公链底层开发（五）</span>
            </a>
        </li>
        
        
        <li class="next">
            <a href="/2017/09/05/blockchain-dev/" data-toggle="tooltip" data-placement="top" title="Go实现公链底层开发（七）">下一篇：  <span>Go实现公链底层开发（七）</span>
            </a>
        </li>
        
    </ul>
</section>

 <section class="footer">
  <footer>
    <div class="footer_div">
      <nav class="cover-navigation navigation--social">
        <ul class="navigation">

          
          <!-- Weibo -->
          <li class="navigation__item_social">
            <a href="http://weibo.com/zhaocongliang" title="@zhaocongliang 的微博" target="_blank">
              <i class='social fa fa-weibo fa-2x'></i>
              <span class="label">Weibo</span>
            </a>
          </li>
           
          <!-- Github -->
          <li class="navigation__item_social">
            <a href="https://github.com/zhaocongliang" title="@zhaocongliang 的 Github" target="_blank">
              <i class='social fa fa-github fa-2x'></i>
              <span class="label">Github</span>
            </a>
          </li>
            

          <!-- RSS -->
          <li class="navigation__item_social">
            <a href="/feed.xml" rel="author" title="RSS" target="_blank">
              <i class='social fa fa-rss fa-2x'></i>
              <span class="label">RSS</span>
            </a>
          </li>

          
          <!-- Email -->
          <li class="navigation__item_social">
            <a href="mailto:zhaocongliang7@163.com" title="Contact me">
              <i class='social fa fa-envelope fa-2x'></i>
              <span class="label">Email</span>
            </a>
          </li>
          

        </ul>
      </nav>

    </div>

    <table width="100%" border="0" cellspacing="0" cellpadding="0">
      <thead>
        <tr id="bar_head">
          <th colspan="11">友情链接</th>
        </tr>
      </thead>

      <tr align="center" valign="middle">

          <td><a href="https://www.ethereum.org">以太坊官网</a></td>

          <td><a href="https://solidity.readthedocs.io/en/develop/">Solidity</a></td>

          <td><a href="http://truffleframework.com/">Truffle FrameWork</a></td>

          <td><a href="http://embark.readthedocs.io">Embark FrameWork</a></td>

          <td><a href="https://www.hyperledger.org/">hyperledger</a></td>

      </tr>
      <tr align="center" valign="middle">

          <td><a href="https://www.ibm.com/developerworks/community/groups/service/html/communityview?communityUuid=3302cc3b-074e-44da-90b1-5055f1dc0d9c&amp;lang=zh">IBM开源技术微讲堂</a></td>

          <td><a href="https://www.bitcoin.com/">Bitcoin.com</a></td>

          <td><a href="https://github.com/bitshares/bitshares1-core">bitshares1-core</a></td>

          <td><a href="https://ipfs.io">ipfs官网</a></td>

          <td><a href="http://ipfser.org">ipfs中文网</a></td>



      </tr>
    </table>

    <div class="footer_div">
      <p class="copyright text-muted">
        <!-- Copyright &copy; 2018 赵从亮区块链博客 京ICP备15065741号.  -->
      </p>
      <div align="right">
        <link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
        <!-- 访问统计
        <span id="busuanzi_container_site_pv">
            本站总访问量
            <span id="busuanzi_value_site_pv"></span>次
        </span>-->

      </div>
      <div>
  </footer>
</section>

    </div>
  </div>

  <script type="text/javascript" src="//code.jquery.com/jquery-1.11.3.min.js"></script>
<script type="text/javascript" src="/js/main.js"></script>

<script type="text/javascript" src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>




  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>


</body>

</html>